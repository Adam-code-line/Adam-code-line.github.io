[{"content":"CSS详解 前言 在之前的CSS 基础知识入门文章中，我们介绍了CSS的基本概念和常用选择器和三种引入方式。本文将更深入地探讨CSS的详细内容，包括CSS的语法解析、值的单位、层叠与继承、盒模型、文档流、布局方式、伪类和伪元素。\nCSS语法解析 CSS的基本语法 CSS的基本语法由选择器(selector)和声明块(declaration block)组成。选择器用于指定要应用样式的HTML元素，声明块包含一个或多个声明，每个声明由属性(property)和属性值(value)组成。CSS语法的基本结构如下：\n1 2 3 selector { property: value; } 例如：\n1 2 3 p { color: red; } 在这个例子中，p是选择器，表示所有的段落元素；color是属性，表示文本颜色；red是属性值，表示将文本颜色设置为红色。声明块就是用大括号{}包裹起来的部分，可以包含多个声明，每个声明之间用分号;分隔。\nCSS的注释 在CSS中，可以使用/*和*/来添加注释。注释不会被浏览器解析和渲染，只用于提高代码的可读性和维护性。注释的语法如下：\n1 2 3 4 /* 这是一个注释 */ p { color: red; } CSS的@规则 @规则用于定义CSS中的特殊指令，如导入外部样式表、定义媒体查询等。常见的@规则包括：\n@import：用于导入其他CSS文件。 @media：用于定义响应式样式，根据不同的设备特性应用不同的样式。 @font-face：用于定义自定义字体。 @keyframes：用于定义动画关键帧。 @charset：用于指定CSS文件的字符编码。 @supports：用于检测浏览器是否支持某个CSS特性。 CSS的值的单位 CSS中常用的值的单位包括绝对单位和相对单位两大类。\n绝对单位 绝对单位是指固定的长度单位，不会随着环境的变化而变化。常见的绝对单位包括：\npx（像素）：最常用的单位，表示屏幕上的一个点。 cm（厘米）：表示厘米。 mm（毫米）：表示毫米。 in（英寸）：表示英寸，1英寸=2.54厘米。 pt（磅）：表示印刷字体的大小，1pt=1/72英寸。 pc（派卡）：表示印刷字体的大小，1pc=12pt。 相对单位 相对单位是相对于其他单位或环境的变化而变化的单位。常见的相对单位包括：\n%（百分比）：相对于父元素的大小。 em：相对于当前元素或者父元素的字体大小。 rem：相对于根元素的字体大小。 vw（视口宽度）：相对于视口的宽度，1vw=1%视口宽度。 vh（视口高度）：相对于视口的高度，1vh=1%视口高度。 CSS的层叠 CSS的全称是层叠样式表（Cascading Style Sheets），其中“层叠”指的是当多个样式规则应用于同一个元素时，浏览器如何决定最终应用哪一个规则,也即优先级的概念。CSS的层叠规则主要包括以下几个方面：\n重要性(Importance) 使用!important声明的样式规则优先级最高，会覆盖其他规则。\n示例：\n1 2 3 4 5 6 p { color: blue !important; } p { color: red; } 在这个例子中，段落文本的颜色将是蓝色，因为!important使得第一个定义p样式的优先级最高。\n后者居上 当多个规则具有相同的重要性时，后定义的规则会覆盖先定义的规则。\n示例：\n1 2 3 4 5 6 p { color: red; } p { color: blue; } 在这个例子中，段落文本的颜色将是蓝色，因为后定义的规则覆盖了先定义的规则。\n来源(Source) CSS样式可以来自不同的来源，优先级从高到低依次为：内联样式、嵌入式样式（\u0026lt;style\u0026gt;标签内）、外部样式表（通过\u0026lt;link\u0026gt;标签引入）。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;head\u0026gt; \u0026lt;style\u0026gt; p { color: green; } \u0026lt;/style\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;styles.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p style=\u0026#34;color: orange;\u0026#34;\u0026gt;This is a paragraph.\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; 在这个例子中，段落文本的颜色将是橙色，因为内联样式的优先级最高。\n特异性(Specificity) 特异性是根据选择器的类型和数量来计算的，特异性高的规则优先级更高。特异性的计算规则如下：\n内联样式（如style属性）具有最高的特异性。 ID选择器（如#id）的特异性高于类选择器（如.class）。 类选择器、属性选择器和伪类选择器的特异性高于元素选择器（如div、p）。 通用选择器（*）和组合选择器的特异性最低。 示例： 1 2 3 4 5 6 7 8 9 #header p { color: green; } .header p { color: orange; } p { color: purple; } 在这个例子中，段落文本的颜色将是绿色，因为ID选择器的特异性最高。特异性也可以理解成具体程度，越具体的选择器优先级越高。\n积分规则 CSS的优先级可以通过积分规则来计算：\n!important：10000分 内联样式：01000分 ID选择器：00100分 类选择器、属性选择器和伪类选择器：00010分 元素选择器和伪元素选择器：00001分 例如：\n1 2 3 4 5 6 7 8 9 #header p { /* 00100 + 00001 = 00101 */ color: green; } .header p { /* 00010 + 00001 = 00011 */ color: orange; } p { /* 00001 */ color: purple; } 在这个例子中，#header p的总积分为00101，.header p的总积分为00011，p的总积分为00001。因此，段落文本的颜色将是绿色，因为它具有最高的积分。在使用多个选择器时，可以通过计算积分来确定最终应用的样式规则。\nCSS的继承 CSS的继承是指某些CSS属性会从父元素传递给子元素。并不是所有的CSS属性都具有继承性，只有一些特定的属性会被继承，我们可以根据常识来判断，不会影响到页面布局的属性通常都能被继承。常见的可继承属性包括：\n文字属性：color、font-family、font-size、font-style、font-weight、line-height、text-align等。 列表属性：list-style、list-style-type、list-style-position等。 表格属性：border-collapse、border-spacing等。 而像margin、padding、border、width、height等属性则不会被继承。 继承的控制 可以使用inherit、initial、unset和关键字来控制继承行为：\ninherit：强制子元素继承父元素的属性值。 示例：\n1 2 3 p { color: inherit; } inherit：强制子元素继承父元素的属性值。 示例：\n1 2 3 p { color: initial; } initial：将属性值重置为其初始值。 示例：\n1 2 3 p { color: unset; } unset：如果属性是可继承的，则继承父元素的值；如果不可继承，则设置为初始值。 CSS 盒模型 盒模型概述 CSS 盒模型是理解网页布局的基础概念。每个HTML元素都可以看作一个矩形盒子，盒模型由四个部分组成：\n内容(content)：盒子的实际内容区域，如文本或图像，可以用inline-size和block-size或者width和height来设置内容的宽度和高度。 内边距(padding)：内容与边框之间的空间，用于增加内容周围的空白区域，用padding属性来设置大小。 边框(border)：包围内容和内边距的线条，可以设置宽度、样式和颜色，用border属性来定义。 外边距(margin)：盒子与其他元素之间的空间，用于控制元素之间的距离，用margin属性来设置大小。 标准盒模型 CSS标准盒模型中，元素的宽度和高度仅包括内容区域的宽度和高度，不包括内边距和边框。即width和height属性设置的值仅仅是内容区域的大小。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .box { width: 200px; height: 100px; padding: 20px; border: 5px solid #333; margin: 30px; background-color: lightgray; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在这个例子中，.box类定义了一个盒子模型，内容区域宽度为200px，高度为100px，内边距为20px，边框宽度为5px，外边距为30px。这里的元素总宽 = 内容宽度 + 左右内边距 + 左右边框 = 200 + 202 + 52 = 250px；总高 = 内容高度 + 上下内边距 + 上下边框 = 100 + 202 + 52 = 150px。\n⬇️ 下载 ⬇️ 下载 其中的199.992×99.984和4.500属于浏览器渲染时的精度偏差。浏览器在渲染元素时，会涉及像素的亚像素（sub-pixel）计算（即像素的细分精度，比如把一个物理像素拆分为多个逻辑像素计算）。这种偏差是浏览器底层渲染引擎的 “精度妥协”，属于正常现象——它不会影响视觉呈现，最终元素的实际显示仍会对齐到物理像素，保证视觉上的清晰。\n替代盒模型 除了标准盒模型外，CSS还提供了替代盒模型，可以通过box-sizing属性来设置。box-sizing属性有两个主要值：\ncontent-box（默认值，也即标准盒模型）：宽度和高度只包括内容区域，不包括内边距和边框，即width和height属性设置的值仅仅是内容区域的大小。\nborder-box：宽度和高度包括内容区域、内边距和边框，即width和height属性设置的值是整个盒子的大小。\n示例：\n1 2 3 4 5 6 7 8 9 .box { box-sizing: border-box; width: 200px; height: 100px; padding: 20px; border: 5px solid #333; background-color: lightgray; margin: 30px; } 在这个例子中，.box类使用了border-box盒模型，因此盒子的总宽度和高度仍然是200px和100px，而不是内容区域的宽度和高度。因此元素的总宽 = 200px，总高 = 100px，内容区域的宽度和高度会根据内边距和边框的大小自动调整。即内容的宽度 = 总宽 - 左右内边距 - 左右边框 = 200 - 202 - 52 = 150px；内容的高度 = 总高 - 上下内边距 - 上下边框 = 100 - 202 - 52 = 50px。\n⬇️ 下载 ⬇️ 下载 大多数开发者更倾向于使用border-box盒模型，因为它更直观，尤其是在进行复杂布局时，可以更容易地控制元素的总大小。\n盒模型的边距和溢出问题 外边距合并(Margin Collapsing) 在CSS盒模型中，外边距（margin）有一个特殊的行为，称为“边距合并”（margin collapsing）。当两个垂直相邻的块级元素的外边距相遇时，浏览器会将它们合并为一个外边距，而不是简单地相加。这意味着最终的外边距大小将是两个外边距中较大的那个。但是如果两个外边距是负值，则取较小的那个值。如果一个是正值一个是负值，则相当于做加法运算。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Margin Collapsing Example\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .box1 { width: 200px; height: 100px; background-color: lightblue; margin-bottom: 30px; } .box2 { width: 200px; height: 100px; background-color: lightcoral; margin-top: 50px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box2\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在这个例子中，.box1的下外边距是30px，.box2的上外边距是50px。由于边距合并，两个盒子之间的实际间距将是50px，而不是80px（30px + 50px）。这是因为浏览器选择了较大的外边距值作为最终的间距。\n⬇️ 下载 ⬇️ 下载 ⬇️ 下载 观感上就像外边距小的那个被大边距“吃掉”了一样。理解边距合并对于布局设计非常重要，尤其是在处理多个块级元素时，可以帮助避免意外的间距问题。解决方法可以使用内边距（padding）或边框（border）来替代外边距，或者添加边框或内边距来阻止边距合并。也可以使用flex布局或grid布局来避免这种情况,这在后面的布局章节中会详细介绍。\n盒子溢出(Overflow) 盒子溢出是指当内容的大小超过其容器的尺寸时，内容会溢出容器的边界。CSS提供了overflow属性来控制溢出内容的显示方式。overflow属性有以下几个常用值：\nvisible：默认值，溢出内容会显示在容器之外。 hidden：溢出内容会被裁剪，不会显示在容器之外。 scroll：无论是否溢出，容器都会显示滚动条。 auto：当内容溢出时，自动显示滚动条。 盒子溢出示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Overflow Example\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .container { width: 200px; height: 100px; border: 2px solid #333; overflow: auto; /* 可以尝试更改为 visible、hidden、scroll */ } .content { width: 300px; height: 150px; background-color: lightgreen; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在这个例子中，.container类定义了一个固定大小的容器，而.content类定义了一个比容器大的内容区域。根据overflow属性的不同设置，溢出内容的显示方式会有所不同。\nCSS的布局方式 CSS提供了多种布局方式，常见的布局方式包括：\n文档流(Document Flow) 在讲解CSS的布局方式之前，我们要先介绍一下文档流的概念。文档流是指HTML元素在页面中的默认排列方式。大多数HTML元素都是按照文档流的顺序从上到下、从左到右排列的。块级元素（如\u0026lt;div\u0026gt;、\u0026lt;p\u0026gt;）默认占据整行，而行内元素（如\u0026lt;span\u0026gt;、\u0026lt;a\u0026gt;）则在一行内排列，直到行满为止。文档流就像水一样，能够自适应所在的容器。当一个节点被移除时，其他节点会自动填补它的位置。如果一个节点脱离了文档流，其他节点就不会再考虑它的位置，会自动填补它的位置。有几种常见的脱离文档流的方式，包括定位布局（positioning）、浮动布局（floating）和弹性盒布局（flexbox）等。\n流式布局(Flow Layout) 流式布局是最基本的布局方式，元素按照文档流的顺序排列。块级元素（如\u0026lt;div\u0026gt;、\u0026lt;p\u0026gt;）默认占据整行，而行内元素（如\u0026lt;span\u0026gt;、\u0026lt;a\u0026gt;）则在一行内排列，直到行满为止。\n定位布局(Positioning Layout) 定位布局允许开发者通过position属性来控制元素的位置。常见的定位方式有：\nstatic：默认值，元素按照文档流排列。 relative：相对于其正常位置进行偏移。 absolute：相对于最近的已定位祖先元素进行定位，如果没有已定位祖先，则相对于初始包含块（通常是\u0026lt;html\u0026gt;元素）定位。 fixed：相对于浏览器窗口进行定位，滚动页面时位置不变。 sticky：在特定的滚动位置下表现为relative，否则表现为fixed。 relative(相对定位)解析： 1 2 3 4 5 .box { position: relative; top: 20px; left: 30px; } 在上面的例子中，.box元素将相对于其正常位置向下移动20px，向右移动30px。这个相对是相对于它在文档流中的原始位置。\nabsolute(绝对定位) 解析： 1 2 3 4 5 6 7 8 .container { position: relative; /* 设定一个已定位的祖先元素 */ } .box { position: absolute; top: 50px; left: 100px; } 在这个例子中，.box元素将相对于其最近的已定位祖先元素.container定位，距离顶部50px，距离左侧100px。注意，如果没有已定位的祖先元素，.box将相对于初始包含块（通常是\u0026lt;html\u0026gt;元素）进行定位。所以，使用absolute定位时，通常会为其祖先元素设置position: relative以确保定位的参考点正确。\nfixed(固定定位) 解析： 1 2 3 4 5 6 .box { position: fixed; top: 10px; right: 10px; } 在这个例子中，.box元素将固定在浏览器窗口的右上角，距离顶部10px，距离右侧10px。无论页面如何滚动，.box的位置都不会改变。\nsticky(粘性定位) 解析： 1 2 3 4 .box { position: sticky; top: 0; } 在这个例子中，.box元素在滚动到达其父容器的顶部时会固定在视口的顶部（距离顶部0px）。在滚动之前，它会按照正常的文档流进行排列。\n注意，sticky定位需要父容器有足够的高度，否则可能无法达到预期效果。且sticky的父级元素不能有overflow: hidden、overflow: scroll或overflow: auto属性，否则会影响其粘性行为。以及flex的布局主轴方向和sticky定位的方向要一致，否则可能无法达到预期效果。要触发粘性效果，需要设置top、bottom、left或right中的至少一个属性。\n浮动布局(Floating Layout) 浮动布局使用float属性将元素从正常文档流中取出，并使其向左或向右浮动。常用于实现文本环绕效果或创建多栏布局。需要注意的是，浮动元素不会影响后续元素的布局，可能需要使用清除浮动（clear）来避免布局问题。\n弹性盒布局(Flexbox Layout) 弹性盒布局使用display: flex属性创建一个灵活的容器，允许子元素在主轴和交叉轴上进行对齐和分配空间。Flexbox非常适合用于一维布局，如水平或垂直排列元素。常用的Flexbox属性包括flex-direction、justify-content、align-items等。\nflex布局的主轴 在Flexbox中，主轴是指元素在容器中排列的方向。主轴的方向可以通过flex-direction属性来设置，常见的取值有：\nrow：默认值，主轴为水平方向，从左到右排列。 row-reverse：主轴为水平方向，从右到左排列。 column：主轴为垂直方向，从上到下排列。 column-reverse：主轴为垂直方向，从下到上排列。 flex布局的交叉轴 交叉轴是指与主轴垂直的方向。交叉轴的方向取决于主轴的方向：\n当主轴为水平方向（row或row-reverse）时，交叉轴为垂直方向。 当主轴为垂直方向（column或column-reverse）时，交叉轴为水平方向。 ⬇️ 下载 出处：https://blog.csdn.net/weixin_51938171/article/details/125548920 flex的内容对齐 在Flexbox中，可以使用justify-content属性来控制主轴上的内容对齐方式，常见的取值有：\nflex-start：默认值，内容向主轴的起始位置对齐。 flex-end：内容向主轴的结束位置对齐。 center：内容在主轴上居中对齐。 space-between：内容在主轴上均匀分布，首尾元素紧贴容器边缘。 space-around：内容在主轴上均匀分布，首尾元素与容器边缘之间留有空隙。 ⬇️ 下载 ⬇️ 下载 flex的尺寸 在Flexbox中，可以使用flex属性来控制子元素在主轴上的尺寸分配。flex属性是一个简写属性，包含三个子属性：flex-grow、flex-shrink和flex-basis。\nflex-grow：定义子元素在主轴上如何增长以填充剩余空间。默认值为0，表示不增长。 flex-shrink：定义子元素在主轴上如何缩小以适应容器。默认值为1，表示可以缩小。 flex-basis：定义子元素在主轴上的初始尺寸。可以设置为具体的长度值（如100px）或百分比（如50%），也可以设置为auto，表示根据内容自动计算尺寸。 示例：\n1 2 3 4 .item { flex: 1 0 100px; /* flex-grow: 1; flex-shrink: 0; flex-basis: 100px; */ } 在这个例子中，.item类的子元素将具有初始尺寸为100px，并且可以增长以填充剩余空间，但不会缩小。设置flex: 1也表示每个子元素将平分剩余空间。即每个元素在主轴上占据相等的空间,这是个无单位的比例值，表示每个元素按比例分配空间。\nflex的换行 默认情况下，Flexbox容器内的子元素会在一行内排列，超出容器宽度时不会换行。可以使用flex-wrap属性来控制子元素的换行行为，常见的取值有：\nnowrap：默认值，子元素不换行，超出容器宽度时会溢出。 wrap：子元素换行，超出容器宽度时会自动换到下一行。 wrap-reverse：子元素换行，超出容器宽度时会自动换到上一行。 网格布局(Grid Layout) 网格布局使用display: grid属性创建一个二维的网格容器，允许开发者定义行和列，并将子元素放置在指定的网格单元格中。Grid布局非常适合用于复杂的网页布局，如报纸式布局。常用的Grid属性包括grid-template-rows、grid-template-columns、grid-gap等。\ngrid布局的行和列 在Grid布局中，可以使用grid-template-rows和grid-template-columns属性来定义网格的行和列。可以使用具体的长度值（如100px）、百分比（如50%）或灵活单位（如fr）来设置行和列的大小。\n示例：\n1 2 3 4 5 6 .container { display: grid; grid-template-rows: 100px 200px; grid-template-columns: 1fr 2fr; grid-gap: 10px; } 在这个例子中，.container类定义了一个Grid容器，包含两行和两列。第一行高度为100px，第二行高度为200px；第一列宽度为1fr，第二列宽度为2fr，表示第二列的宽度是第一列的两倍。grid-gap属性用于设置网格单元格之间的间距。\ngrid布局的子元素定位 在Grid布局中，可以使用grid-row和grid-column属性来控制子元素在网格中的位置。可以指定子元素跨越的行和列。\n示例：\n1 2 3 4 5 6 7 8 .item1 { grid-row: 1 / 2; /* 跨越第一行 */ grid-column: 1 / 3; /* 跨越第一列和第二列 */ } .item2 { grid-row: 2 / 3; /* 跨越第二行 */ grid-column: 1 / 2; /* 跨越第一列 */ } 在这个例子中，.item1类的子元素将跨越第一行和第一列、第二列，而.item2类的子元素将跨越第二行和第一列。在观感上，.item1会占据网格的第一行的全部宽度，而.item2会占据第二行的第一列。\ngrid布局的自动放置 Grid布局还支持自动放置子元素，可以使用grid-auto-rows和grid-auto-columns属性来定义自动生成的行和列的大小。\n示例：\n1 2 3 4 5 6 .container { display: grid; grid-auto-rows: 100px; grid-auto-columns: 1fr; grid-gap: 10px; } 在这个例子中，.container类定义了一个Grid容器，自动生成的行高度为100px，自动生成的列宽度为1fr，表示每列宽度相等。grid-gap属性用于设置网格单元格之间的间距。\ngrid布局的对齐 在Grid布局中，可以使用justify-items和align-items属性来控制子元素在网格单元格内的对齐方式。常见的取值有：\nstart：子元素向单元格的起始位置对齐。 end：子元素向单元格的结束位置对齐。 center：子元素在单元格内居中对齐。 stretch：默认值，子元素拉伸以填充整个单元格。 CSS的伪类和伪元素 伪类(Pseudo-classes) 伪类用于定义元素的特殊状态或条件，可以分为四种，分别是条件伪类、行为伪类、状态伪类和结构伪类。\n条件伪类 条件伪类用于根据元素的特定条件来应用样式，常见的条件伪类有：\n:lang()：根据元素的语言属性应用样式。 :not()：选择不符合特定条件的元素。 :has()：选择包含特定子元素的元素。 :is()：选择符合多个选择器条件的元素。 :dir()：根据元素的文本方向应用样式。 行为伪类 行为伪类用于根据用户与元素的交互行为来应用样式，常见的行为伪类有：\n:hover：当用户将鼠标悬停在元素上时应用样式。 :active：当用户点击并按下元素时应用样式。 :focus：当元素获得焦点时应用样式。 状态伪类 状态伪类用于根据元素的状态来应用样式，常见的状态伪类有：\n:checked：选择被选中的复选框或单选按钮。 :disabled：选择被禁用的表单元素。 :enabled：选择可用的表单元素。 :required：选择必填的表单元素。 :valid：选择有效的表单元素。 :invalid：选择无效的表单元素。 结构伪类 结构伪类用于根据元素在文档结构中的位置来应用样式，常见的结构伪类有：\n:first-child：选择作为其父元素的第一个子元素的元素。 :last-child：选择作为其父元素的最后一个子元素的元素。 :nth-child(n)：选择作为其父元素的第n个子元素的元素。 :nth-last-child(n)：选择作为其父元素的倒数第n个子元素的元素。 :only-child：选择作为其父元素唯一子元素的元素。 :root：选择文档的根元素。 :empty：选择没有子元素的元素。 伪元素(Pseudo-elements) 伪元素用于创建元素的虚拟子元素，常见的伪元素有：\n::before：在元素内容之前插入内容。 ::after：在元素内容之后插入内容。 ::first-letter：选择元素的第一个字母。 ::first-line：选择元素的第一行文本。 示例：\n1 2 3 4 5 6 7 8 p::before { content: \u0026#34;Note: \u0026#34;; font-weight: bold; } p::after { content: \u0026#34; (end of paragraph)\u0026#34;; font-style: italic; } 在这个例子中，::before伪元素在每个段落内容之前插入了“Note: ”，并将其设置为粗体；::after伪元素在段落内容之后插入了“ (end of paragraph)”，并将其设置为斜体。\n结语 本文详细介绍了CSS的层叠与继承、盒模型、布局方式以及伪类和伪元素等内容。CSS是前端开发中不可或缺的技术，它的上手相对简单，但是想要精通却很困难。在之后的开发中除了原生CSS外，我们还会接触到各种CSS预处理器（如Sass、Less）和CSS框架（如Bootstrap、Tailwind CSS），这些工具可以帮助我们更高效地编写和管理CSS代码。本文仅对CSS做了一些详细的介绍，后面还需要自己不断学习和实践。\n参考资料 MDN Web Docs - CSS 构建 深入理解CSS盒子模型：从基础到实战 （第四回） 解析CSS面试考点：盒模型、选择器、单位和像素概念，一网打尽！ flex布局在css中的使用，一看就会 CSS3最强布局-Grid布局 1.5 万字 CSS 基础拾遗（核心知识、常见需求） ","date":"2025-10-31T20:50:21+08:00","permalink":"https://adam-code-line.github.io/p/dtails-for-css/","title":"CSS详解"},{"content":"Next.js学习 Next.js简介 Next.js是一个基于React的全栈框架，提供了服务器端渲染（SSR）、静态站点生成（SSG）等功能，极大地简化了React应用的开发流程。在React弃用Create React App (CRA)之后，React官方就推荐使用框架来构建应用，而Next.js是目前React最主流的框架，拥有庞大的社区和丰富的生态系统，对于一个想用React构建一个新的应用或网站的开发者来说，Next.js无疑是一个非常好的选择。作为一个全栈框架，Next.js不仅可以用于构建前端界面，还可以处理后端逻辑，使得开发者可以在同一个项目中同时处理前后端代码，极大地提高了开发效率。\nNext.js的核心特性 Next.js有着许多重要的特性，以下是其中一些核心特性：\n服务器端渲染（SSR） 服务器端渲染是Next.js的一个重要特性，它允许在服务器上预先渲染React组件，然后将生成的HTML发送到客户端。这种方式不仅提高了页面加载速度，还对SEO非常友好，因为搜索引擎可以更容易地抓取预渲染的内容。Next.js通过getServerSideProps函数实现SSR，可以在这个函数中获取数据并传递给页面组件。\n静态站点生成（SSG） 静态站点生成是Next.js的另一个重要特性，它允许在构建时预先生成静态HTML文件，然后在请求时直接提供这些文件。SSG适用于内容不频繁变化的页面，如博客文章、产品展示等。Next.js通过getStaticProps和getStaticPaths函数实现SSG，可以在这些函数中获取数据并生成静态页面。\nAPI路由 Next.js内置了API路由功能，允许开发者在项目中创建后端API接口。在app下可以创建api文件夹，然后可以在api文件夹下创建如route.ts的文件来定义API路由，在route.ts中编写处理请求、身份验证等的代码。\n文件系统路由 Next.js采用文件系统路由的方式，根据app目录下的文件和文件夹结构自动生成路由。这种方式使得路由管理变得非常简单，只需创建相应的文件和文件夹即可定义路由，无需手动配置路由表。后面我会详细介绍文件系统路由的使用方法。\n内置CSS和Sass支持 Next.js内置了对CSS和Sass的支持，允许开发者直接在组件中导入CSS或Sass文件进行样式管理。此外，Next.js还支持CSS模块化，避免了样式冲突的问题。开发者可以通过创建.module.css或.module.scss文件来实现组件级别的样式隔离。\n图片优化 Next.js提供了内置的图片优化功能，通过next/image组件可以自动处理图片的大小、格式和质量，提升页面加载速度和用户体验。使用next/image组件替代传统的\u0026lt;img\u0026gt;标签，可以很方便地实现响应式图片和懒加载等功能。\n开始使用Next.js 创建Next.js项目 要创建一个新的Next.js项目，可以使用以下命令：\n1 2 npx create-next-app@latest 这将启动一个交互式的命令行工具，帮助你配置项目的基本设置。你可以选择使用TypeScript、ESLint等选项。\n运行开发服务器 进入项目目录后，可以使用以下命令启动开发服务器：\n1 npm/pnpm run dev 这将在http://localhost:3000启动开发服务器，你可以在浏览器中访问该地址查看你的Next.js应用。\n项目结构 Next.js项目的基本结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 my-app/ ├── .next/ ├── app/ │ ├── api/ │ ├── layout.tsx │ ├── page.tsx │ └── ... ├── components/ ├── node_modules/ ├── public/ ├── next.config.js ├── package.json └── ... app/：存放应用的页面和布局文件。 components/：存放可复用的React组件。 public/：存放静态资源，如图片、字体等。 next.config.js：Next.js的配置文件。 package.json：项目的依赖和脚本配置文件。 以上并非完整的项目结构，只是一个简要的概览，实际项目中可能会有更多的文件和文件夹。\nESLint和Prettier配置 ESLint配置 Next.js默认集成了ESLint，可以帮助你保持代码质量和一致性。如果你在创建项目时选择了ESLint选项，Next.js会自动生成一个.eslintrc.config.mjs文件，你可以根据需要进行修改和扩展。如果你使用VS Code，可以安装ESLint插件，以便在编辑器中实时检查代码问题。\n创建项目默认生成的ESLint配置文件内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import { defineConfig, globalIgnores } from \u0026#34;eslint/config\u0026#34;; import nextVitals from \u0026#34;eslint-config-next/core-web-vitals\u0026#34;; import nextTs from \u0026#34;eslint-config-next/typescript\u0026#34;; const eslintConfig = defineConfig([ ...nextVitals, ...nextTs, // Override default ignores of eslint-config-next. globalIgnores([ // Default ignores of eslint-config-next: \u0026#34;.next/**\u0026#34;, \u0026#34;out/**\u0026#34;, \u0026#34;build/**\u0026#34;, \u0026#34;next-env.d.ts\u0026#34;, ]), ]); export default eslintConfig; 其中，nextVitals和nextTs分别包含了Next.js核心Web Vitals和TypeScript相关的ESLint规则。globalIgnores用于定义全局忽略的文件和文件夹，避免ESLint检查这些文件。\nprettier配置 Next.js项目通常也会集成Prettier，用于代码格式化。如果你使用VS Code，可以下载Prettier插件，以便在编辑器中自动格式化代码。你可以在项目中安装Prettier依赖：\n1 npm/pnpm install --save-dev prettier 然后在项目根目录下创建一个.prettierrc文件，配置Prettier的选项。例如：\n1 2 3 4 5 6 { \u0026#34;semi\u0026#34;: true, \u0026#34;singleQuote\u0026#34;: true, \u0026#34;tabWidth\u0026#34;: 2, \u0026#34;trailingComma\u0026#34;: \u0026#34;es5\u0026#34; } 这里的配置选项包括是否使用分号、单引号、制表符宽度和尾随逗号等。你可以根据实际情况进行调整。\n集成ESLint和Prettier 为了避免ESLint和Prettier之间的冲突，可以安装eslint-config-prettier和eslint-plugin-prettier，并在ESLint配置文件中进行相应的设置：\n1 npm/pnpm install --save-dev eslint-config-prettier eslint-plugin-prettier 然后在.eslintrc.config.mjs中添加以下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import prettierConfig from \u0026#34;eslint-config-prettier\u0026#34;; import prettierPlugin from \u0026#34;eslint-plugin-prettier\u0026#34;; const eslintConfig = defineConfig([ ...nextVitals, ...nextTs, ...prettierConfig, { plugins: [prettierPlugin], rules: { \u0026#34;prettier/prettier\u0026#34;: \u0026#34;error\u0026#34;, }, }, // Override default ignores of eslint-config-next. globalIgnores([ // Default ignores of eslint-config-next: \u0026#34;.next/**\u0026#34;, \u0026#34;out/**\u0026#34;, \u0026#34;build/**\u0026#34;, \u0026#34;next-env.d.ts\u0026#34;, ]), ]); export default eslintConfig; 这样，ESLint会使用Prettier的规则进行代码格式检查，确保代码风格的一致性。\n创建布局与页面 在Next.js中，布局文件通常命名为layout.tsx，用于定义应用的整体结构和样式。页面文件通常命名为page.tsx，用于定义具体的页面内容。你可以在app目录下找到这些文件，并根据需要进行修改和扩展。也可以在app目录下创建子文件夹来组织不同的页面和布局。Next.js会根据文件夹结构自动生成相应的路由。\n例如我想创建about页面，可以在app目录下创建一个名为about的文件夹，然后在该文件夹下创建layout.tsx，page.tsx文件，内容如下：\n1 2 3 4 5 6 7 8 9 // app/about/layout.tsx export default function AboutLayout({ children }: { children: React.ReactNode }) { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;About Us\u0026lt;/h1\u0026gt; \u0026lt;main\u0026gt;{children}\u0026lt;/main\u0026gt; \u0026lt;/div\u0026gt; ); } 1 2 3 4 // app/about/page.tsx export default function AboutPage() { return \u0026lt;p\u0026gt;This is the about page.\u0026lt;/p\u0026gt;; } 这样就创建了一个/about路由，对应的页面内容为\u0026quot;This is the about page.\u0026quot;，并且使用了AboutLayout作为布局。可以访问http://localhost:3000/about来查看效果。\n使用API路由 要创建API路由，可以在app/api目录下创建相应的文件夹和文件。例如，创建一个名为hello的API路由，可以在app/api/hello/route.ts中编写如下代码：\n1 2 3 4 5 import { NextResponse } from \u0026#39;next/server\u0026#39;; export async function GET() { return NextResponse.json({ message: \u0026#39;Hello, Next.js API!\u0026#39; }); } 这样就创建了一个/api/hello的API路由，可以通过发送GET请求来获取响应。可以使用浏览器或Postman等工具访问http://localhost:3000/api/hello来查看效果。\n自定义配置 Next.js允许通过next.config.js文件进行自定义配置。你可以在该文件中设置各种选项，如环境变量、Webpack配置等。例如，以下是一个简单的next.config.js示例：\n1 2 3 4 5 6 7 import { NextConfig } from \u0026#39;next\u0026#39;; const nextConfig: NextConfig = { reactStrictMode: true, swcMinify: true, }; module.exports = nextConfig; 这个配置启用了React严格模式和SWC压缩，可以根据项目需求进行调整和扩展。\n部署Next.js应用 Next.js应用可以部署到多种平台，如Vercel、Netlify、AWS等。Vercel是Next.js的官方部署平台，提供了无缝的集成和优化。要部署到Vercel，可以按照以下步骤操作：\n在Vercel官网注册并登录账号。 连接你的GitHub/GitLab/Bitbucket仓库。 选择要部署的Next.js项目。 配置构建和部署选项，然后点击“Deploy”按钮。 Vercel会自动构建并部署你的Next.js应用，完成后会提供一个访问链接。需要注意的是Vercel对免费账号有一定的使用限制，具体可以参考Vercel官网的说明。\n结语 Next.js是一个十分好用的React全栈框架，也是现在国内很多公司使用的主流框架。学习Next.js对于提升React开发技能和构建高性能Web应用非常有帮助。\n参考资料 Next.js官方文档 Vercel官方文档 VSCode 自动格式化：ESLint 与 Prettier NEXT.js 中文文档 Next.js 项目最佳实践 ","date":"2025-10-29T19:55:32+08:00","permalink":"https://adam-code-line.github.io/p/nextjs-study/","title":"Next.js学习(一)"},{"content":"React的State状态 在React中，State（状态）是组件用于存储和管理数据的对象。State的变化会触发组件的重新渲染，从而更新UI以反映最新的数据状态。State通常用于存储用户输入、服务器响应数据或其他动态信息。可以把State看成组件的“记忆”，它记录了组件在不同时间点上的数据状态。\nState的作用 React中的State扮演着重要的角色，主要有以下几个作用：\n数据存储 State用于存储组件的动态数据，这些数据可能会随着用户交互或其他事件而变化。\nUI更新 当State发生变化时，React会自动重新渲染组件，以确保UI与最新的State保持同步。\n组件交互 State允许组件根据用户的操作或其他事件动态地改变其行为和外观。\n状态管理 State是React中管理组件状态的核心机制，帮助开发者构建交互性强的用户界面。\nState的分类 根据Stated的作用范围，State可以分为以下几类：\n本地State 每个组件都有自己的本地State，通常使用 useState Hook 来管理。它只在组件内部使用，不会被其他组件访问。\n提升State 当多个组件需要共享同一份State时，可以将State提升到它们的共同父组件中进行管理。这样，父组件可以通过props将State传递给子组件。\n全局State 对于大型应用程序，可能需要在多个组件之间共享State。可以使用React的Context API或状态管理库（如Redux、MobX）来管理全局State。\nuseState useState 是React中用于在函数组件中添加State的Hook。它允许你在函数组件中声明State变量，并提供一个更新函数来修改这些变量。useState 的使用非常简单，下面是它的详细解释：\n1 const [state, setState] = useState(initialState); state: 当前的State变量，可以是任何类型的数据（数字、字符串、对象、数组等）。 setState: 用于更新State变量的函数。调用这个函数会触发组件的重新渲染。 initialState: State变量的初始值，可以是一个具体的值，也可以是一个函数，该函数返回初始值（用于惰性初始化）。 useState原理 useState 的原理基于React的Hooks机制。当你调用 useState 时，React会在内部为该组件实例分配一个存储位置，用于保存State变量的值。每次组件渲染时，React都会根据调用顺序来识别和管理这些State变量。\nuseState的惰性初始化 有时，初始State的计算可能比较复杂，或者需要从某些外部资源获取数据。为了避免每次渲染时都进行这些计算，可以将初始State设置为一个函数，这个函数只会在组件首次渲染时调用一次。\n1 2 3 4 const [count, setCount] = useState(() =\u0026gt; { // 复杂的初始值计算 return computeInitialCount(); }); 在这个例子中，computeInitialCount 函数只会在组件首次渲染时调用一次，以计算 count 的初始值。\n添加State变量 在React中，可以通过使用 useState Hook 来添加State变量。useState 是一个函数，它接受初始状态作为参数，并返回一个包含当前状态和更新状态的函数的数组。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //MyComponent.jsx import React, { useState } from \u0026#39;react\u0026#39;; function Counter() { // 声明一个名为 \u0026#34;count\u0026#34; 的 state 变量，初始值为 0 const [count] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;当前计数: {count}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } 在上面的例子中，我们使用 useState(0) 来创建一个名为 count 的State变量，初始值为0。注意不要在循环、条件语句或嵌套函数中调用 useState，因为Hooks必须在组件的顶层调用，以确保每次渲染时都能以相同的顺序调用。\n更新State 使用更新函数 要更新State变量，可以使用 useState 返回的更新函数。在上面的例子中，我们可以使用 setCount 函数来更新 count 的值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //MyComponent.jsx import React, { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;当前计数: {count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;增加计数\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 在这个例子中，当用户点击按钮时，setCount(count + 1) 会被调用，count 的值会增加1，并触发组件重新渲染以显示最新的计数值。要注意的是使用state更新函数时，确保不会直接修改State变量，而是通过调用更新函数来实现状态的更新。比如不能直接写 count = count + 1，而应该使用 setCount(count + 1)。\nState的异步更新 在React中，State的更新是异步的，这意味着当你调用更新函数时，State不会立即更新，而是在下一次渲染时才会反映最新的状态。这种行为有助于提高性能，因为React可以批量处理多个State更新。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //MyComponent.jsx import React, { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); const handleClick = () =\u0026gt; { setCount(count + 1); console.log(count); // 这里可能不会打印最新的 count 值 }; return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;当前计数: {count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;增加计数\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 在上面的例子中，当用户点击按钮时，setCount(count + 1) 会被调用，但紧接着的 console.log(count) 可能不会打印最新的 count 值，因为State更新是异步的。如果需要在State更新后执行某些操作，可以使用 useEffect Hook 来监听State的变化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //MyComponent.jsx import React, { useState, useEffect } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); useEffect(() =\u0026gt; { console.log(count); // 这里会打印最新的 count 值 }, [count]); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;当前计数: {count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;增加计数\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 在这个例子中，useEffect 会在 count 发生变化时执行，从而打印最新的 count 值。\n多个State变量管理 在React中，可以在一个组件中使用多个State变量来管理不同的数据。每个State变量都可以独立更新和管理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //MyComponent.jsx import React, { useState } from \u0026#39;react\u0026#39;; function UserProfile() { const [name, setName] = useState(\u0026#39;张三\u0026#39;); const [age, setAge] = useState(25); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;姓名: {name}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;年龄: {age}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setName(\u0026#39;李四\u0026#39;)}\u0026gt;更改姓名\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; setAge(age + 1)}\u0026gt;增加年龄\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 在上面的例子中，我们创建了两个State变量 name 和 age，分别用于存储用户的姓名和年龄。每个State变量都有自己的更新函数，可以独立更新。注意不要在一个State中引用另一个State变量的值进行更新，以避免潜在的同步问题。\nState在组件中 State在独立组件中 每一个React组件实例都有自己的State，这意味着同一个组件类的不同实例可以有不同的State值。这使得组件可以在不同的上下文中表现出不同的行为和外观。同时与props不同，State完全私有于声明它的组件，父组件无法更改子组件的State。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 //MyComponent.jsx import React, { useState } from \u0026#39;react\u0026#39;; export default function Counter() { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;当前计数: {count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;增加计数\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } //App.jsx import React from \u0026#39;react\u0026#39;; import Counter from \u0026#39;./MyComponent\u0026#39;; export default function App() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;计数器实例1\u0026lt;/h1\u0026gt; \u0026lt;Counter /\u0026gt; \u0026lt;h1\u0026gt;计数器实例2\u0026lt;/h1\u0026gt; \u0026lt;Counter /\u0026gt; \u0026lt;/div\u0026gt; ); } 在上面的例子中，App 组件渲染了两个 Counter 组件实例。每个 Counter 实例都有自己的State变量 count，它们的值是独立的，互不影响。\nState在多个组件间共享 如果希望在多个组件之间共享State,可以将State提升到它们的共同父组件中，或者使用React的Context API或状态管理库（如Redux）来实现更复杂的状态共享和管理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 //MyComponent.jsx import React from \u0026#39;react\u0026#39;; export default function Counter({ count, setCount }) { return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;当前计数: {count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={setCount}\u0026gt;增加计数\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } //App.jsx import React, { useState } from \u0026#39;react\u0026#39;; import Counter from \u0026#39;./MyComponent\u0026#39;; export default function App() { const [count, setCount] = useState(0); function setCountValue() { setCount(count + 1); } return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;共享计数器\u0026lt;/h1\u0026gt; \u0026lt;Counter count={count} setCount={setCountValue} /\u0026gt; \u0026lt;Counter count={count} setCount={setCountValue} /\u0026gt; \u0026lt;/div\u0026gt; ); } 在上面的例子中，App 组件管理了 count State，并将其作为props传递给 Counter 组件。这样，Counter 组件可以共享和更新 App 组件中的State。\n结语 State是前端开发中非常重要的概念。在vue、flutter框架中也会有类似的状态概念。而状态管理更是前端开发中的核心工作之一，理解和掌握State的使用对于构建动态和交互性强的用户界面至关重要。\n参考资料 React官方文档 - 状态管理 React官方文档 - State：组件的记忆 ","date":"2025-10-29T19:55:32+08:00","permalink":"https://adam-code-line.github.io/p/react-state/","title":"React的State状态"},{"content":"React 学习概述 前言 React是由Facebook开发的一个用于构建用户界面的JavaScript库。它采用组件化的开发方式，使得构建复杂的应用变得更加简单和高效。React的核心特点包括声明式编程、组件化、虚拟DOM和单向数据流等。这些我下面都会一一介绍：\nReact的核心概念 声明式编程 React采用声明式编程范式，开发者只需描述UI在不同状态下的样子，React会负责更新和渲染组件。这种方式使得代码更加简洁易读，减少了手动操作DOM的复杂性。\nJSX语法 JSX是一种JavaScript的语法扩展，允许在JavaScript代码中直接编写类似HTML的代码。JSX使得定义组件的结构更加直观。\n组件（Components） 组件是React应用的基本构建块。每个组件都是一个独立的、可复用的UI单元，可以包含自己的状态和逻辑。组件可以是函数组件或类组件。组件化就是将整体UI拆分成多个小的、独立的部分，从而提高代码的可维护性和复用性。\n虚拟DOM（Virtual DOM） React使用虚拟DOM来提高性能。虚拟DOM是一个轻量级的JavaScript对象，表示真实DOM的副本。当组件的状态发生变化时，React会首先更新虚拟DOM，然后通过比较新旧虚拟DOM的差异，最小化地更新真实DOM。\n单向数据流（One-way Data Flow） React采用单向数据流的设计理念，数据从父组件传递到子组件。这样可以更容易地追踪数据的变化，提升应用的可维护性。\n状态管理（State Management） React组件可以拥有自己的状态（state），用于存储组件的动态数据。状态的变化会触发组件的重新渲染。对于复杂的应用，可以使用状态管理库（如Redux、MobX）来集中管理应用的状态。\nReact Hooks React Hooks是React 16.8引入的一组函数，允许在函数组件中使用状态和其他React特性。常用的Hooks包括useState、useEffect、useContext等。\n快速开始 React在2025年2月就表明正式弃用Create React App作为新应用的推荐工具，并建议现有应用迁移至框架(如Next.js、Remix等)或使用现代构建工具(如Vite、parcel等)来创建React项目。所以在读一些旧文档的时候要注意这一点。下面我以Vite为例，介绍如何快速创建一个React项目：\n1 2 3 4 5 6 7 8 9 10 11 12 # 全局安装pnpm（可选），也可直接使用npm创建 npm install -g pnpm # 创建一个新的Vite项目 pnpm create vite@latest my-react-app --template react # 进入项目目录 cd my-react-app # 安装依赖 pnpm install # 启动开发服务器 pnpm dev 打开浏览器访问http://localhost:5173即可预览React应用。\nReact 组件命名规范 在React中，组件的命名通常遵循以下规范：\n组件名称应以大写字母开头，以区分HTML标签和自定义组件。如果组件名称由多个单词组成，每个单词的首字母均应大写（驼峰命名法）。例如：MyComponent、UserProfile。 组件名称应具有描述性，能够清晰地表达组件的功能和用途。比如：Button、Header、Footer等。 组件文件名应与组件名称一致，使用驼峰命名法（CamelCase）。例如：MyComponent.jsx、UserProfile.js。 JSX 示例与规则 JSX 示例 1 2 3 4 5 6 7 import React from \u0026#39;react\u0026#39;; const HelloWorld = () =\u0026gt; { //() =\u0026gt; 是箭头函数的写法，等价于 function HelloWorld() {} return \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt;; } export default HelloWorld; 这个简单的组件使用了JSX语法来定义一个返回\u0026lt;h1\u0026gt;元素的函数组件。其中import语句用于引入React库，HelloWorld组件返回一个包含文本\u0026quot;Hello, World!\u0026ldquo;的标题元素。export语句用于将组件导出，以便在其他文件中使用。default关键字表示这是该文件的默认导出。一个文件只能有一个默认导出。但可以有多个命名导出。关于这方面的内容在后续的文章中我会更详细地介绍。\nJSX 规则 JSX只能返回一个根元素 在JSX中，组件必须返回一个单一的根元素。如果需要返回多个元素，可以使用一个父元素将它们包裹起来，或者使用React.Fragment（简写为\u0026lt;\u0026gt;\u0026hellip;\u0026lt;/\u0026gt;）来实现。例如：\n1 2 3 4 5 6 return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Welcome to React!\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); 或者使用Fragment：\n1 2 3 4 5 6 return ( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Welcome to React!\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; ); 标签必须闭合 在JSX中，所有的标签都必须闭合。对于自闭合标签（如\u0026lt;img\u0026gt;、\u0026lt;input\u0026gt;等），必须使用斜杠/\u0026gt;来闭合。例如：\n1 \u0026lt;img src=\u0026#34;image.jpg\u0026#34; alt=\u0026#34;Image\u0026#34; /\u0026gt; 对于只有开始标签的标签（如\u0026lt;ul\u0026gt;、\u0026lt;li\u0026gt;等），必须添加结束标签。例如：\n1 2 3 4 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Item 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Item 2\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 使用大括号嵌入JavaScript表达式 在JSX中，可以使用大括号{}来嵌入JavaScript表达式。例如：\n1 2 3 export default function Greeting({ name }) { return \u0026lt;h1\u0026gt;Hello, {name}!\u0026lt;/h1\u0026gt;; } 此处，{name}会被替换为变量name的值。\n还可以用双大括号来嵌入对象字面量，例如：\n1 2 3 export default function StyledDiv() { return \u0026lt;div style={{ color: \u0026#39;red\u0026#39;, fontSize: \u0026#39;20px\u0026#39; }}\u0026gt;Styled Text\u0026lt;/div\u0026gt;; } 使用驼峰命名法 在JSX中，属性名称应使用驼峰命名法（camelCase）。例如，使用className代替class，使用onClick代替onclick。例如：\n1 \u0026lt;button className=\u0026#34;btn\u0026#34; onClick={handleClick}\u0026gt;Click Me\u0026lt;/button\u0026gt; TSX 示例与规则 TSX 示例 1 2 3 4 5 6 import React from \u0026#39;react\u0026#39;; const HelloWorld: React.FC = () =\u0026gt; { return \u0026lt;h1\u0026gt;Hello，World!\u0026lt;/h1\u0026gt;; } export default HelloWorld; 这个示例展示了如何在React中使用TypeScript（TSX）来定义一个函数组件。与前面的JSX示例类似，这个组件返回一个包含文本\u0026quot;Hello, World!\u0026ldquo;的标题元素。不同之处在于，组件的类型被显式地声明为React.FC（Function Component），这有助于TypeScript进行类型检查和代码补全。React.FC是React提供的一个类型，用于定义函数组件的类型。后面我会对这个进行更详细的说明。TSX的语法规则与JSX类似，增加了类型注解和接口定义等TypeScript特性。就不在这里多说了。\nTSX 规则 TSX的规则与JSX类似，但增加了类型注解和接口定义等TypeScript特性。以下是一些常见的TSX规则：\n类型注解 在TSX中，可以为组件的props和state添加类型注解。例如：\n1 2 3 4 5 6 7 interface GreetingProps { name: string; } const Greeting: React.FC\u0026lt;GreetingProps\u0026gt; = ({ name }) =\u0026gt; { return \u0026lt;h1\u0026gt;Hello, {name}!\u0026lt;/h1\u0026gt;; } 使用接口定义props 可以使用接口（interface）来定义组件的props类型。例如：\n1 2 3 4 5 6 7 8 interface ButtonProps { label: string; onClick: () =\u0026gt; void; } const Button: React.FC\u0026lt;ButtonProps\u0026gt; = ({ label, onClick }) =\u0026gt; { return \u0026lt;button onClick={onClick}\u0026gt;{label}\u0026lt;/button\u0026gt;; } TSX的语法规则与JSX类似，增加了类型注解和接口定义等TypeScript特性。就不在这里多说了。\n组件示例 React应用程序是由组件组成的，一个组件可以包含其他组件，以下是一个简单的React函数组件示例，实现了一个计数器功能：\n1 2 3 4 5 6 7 8 9 10 11 12 13 import React, { useState } from \u0026#39;react\u0026#39;; const Counter = () =\u0026gt; { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count: {count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }; export default Counter; 这个组件使用了useState Hook来管理计数器的状态。当点击按钮时，计数器的值会增加1，并触发组件重新渲染以显示最新的计数值。\n注意事项: 组件中可以包含其他组件，但是不能在组件内部定义组件。组件应该在文件的顶层定义，以确保它们在每次渲染时保持一致。\nHooks 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import React, { useState, useEffect } from \u0026#39;react\u0026#39;; const Timer = () =\u0026gt; { const [seconds, setSeconds] = useState(0); useEffect(() =\u0026gt; { const interval = setInterval(() =\u0026gt; { setSeconds((prev) =\u0026gt; prev + 1); }, 1000); return () =\u0026gt; clearInterval(interval); }, []); return \u0026lt;div\u0026gt;Timer: {seconds} seconds\u0026lt;/div\u0026gt;; }; export default Timer; 这个组件使用了useEffect Hook来设置一个定时器，每秒钟更新一次计数器的值。当组件卸载时，清除定时器以避免内存泄漏。\n结语 React是一个功能强大的JavaScript库，很多大厂都在使用React,它也是目前前端开发的主流框架，所以学习React是非常有必要的。因为React的知识体系庞大且较为复杂，本文只作为入门概述，建议结合官方文档和实际项目进行深入学习和实践，后面我也会一步步更新React的学习文档，不断深化理解。\n参考资料 React 官方文档 ","date":"2025-10-29T19:55:32+08:00","permalink":"https://adam-code-line.github.io/p/react-learning-guide/","title":"React概述"},{"content":"HTML详解 前言 之前的HTML 基础知识入门文章中我已经介绍了HTML的基础知识，在本文中我会进行更详细的讲解。\nHTML 概述 先来回顾一下HTML的概念，HTML全称为超文本标记语言(Hyper Text Markup Language),是构建网页和Web应用的标准标记语言，超文本（hypertext）是指连接单个网站内或多个网站间的网页的链接标记(markup)用来注明文本、图片和其他内容。HTML使用一系列标签和属性来定义网页的结构和内容,包括文本、图像、链接、表格、表单等元素。浏览器通过解析HTML代码,将其渲染为用户可以看到和交互的网页界面。需要明确的是HTML本身并不是一种编程语言，而是标记语言,它主要用于描述网页的结构和内容,而不是实现逻辑和功能。HTML通常与CSS(层叠样式表)和JavaScript一起使用,以实现网页的样式和交互功能。\nHTML 的基本结构 在之前的HTML 基础知识入门中我们已经介绍了 HTML 的基本结构,并简单讲解了一些基本标签，下面我将更详细地讲解HTML的基本结构：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;HTML详解\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/x-icon\u0026#34; href=\u0026#34;favicon.ico\u0026#34;\u0026gt; \u0026lt;style\u0026gt; body { font-family: Arial, sans-serif; margin: 20px; line-height: 1.6; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; DOCTYPE DOCTYPE是HTML5的文档声明，它可以告诉浏览器，使用哪一个HTML版本解析文档。在浏览器发展的过程中出现过很多HTML的版本，如果没有提前告诉浏览器，那么浏览器就不知道文档解析标准是什么。此时，大部分浏览器将开启最大兼容模式来解析网页，我们一般称为怪异模式，这不仅会降低解析效率，而且会在解析过程中产生一些难以预知的bug，所以文档声明是必须的。\nhtml \u0026lt;html\u0026gt;标签是HTML文档的根元素，所有其他HTML元素都必须包含在\u0026lt;html\u0026gt;标签内。lang属性指定了文档的语言，这对于搜索引擎优化(SEO)和辅助技术(如屏幕阅读器)非常重要。在这里，zh-CN表示中文(中国大陆)。常见的还有en(英语)、fr(法语)、es(西班牙语)等。\nhead \u0026lt;head\u0026gt;标签包含了文档的元数据(metadata)，这些信息不会直接显示在网页上，但对网页的功能和表现非常重要。常见的元数据包括字符集声明、页面标题、样式表链接、脚本文件链接等。meta就是元，data就是数据，元数据是用来描述数据的数据，如一个数据200，我们并不知道这个数据代表什么，但是体重：200，我们就可以知道这个数据代表体重200斤，其中的体重就是元数据，它用来描述200这个数据。下面来详细介绍几个常用的元数据标签以及标签中属性的含义。\nmeta \u0026lt;meta\u0026gt;标签用于定义文档的元数据，如字符集、作者、描述等。\u0026lt;meta\u0026gt;常见的属性有：\ncharset：指定文档的字符编码，如\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;表示使用UTF-8编码，这是一种支持多种语言字符的编码方式，推荐使用。\nname和content：name属性主要用于描述网页，与其搭配使用的content属性用于提供具体的信息,content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的,常见的name属性有：\ndescription：网页的简要描述，有助于搜索引擎理解网页内容，如\u0026lt;meta name=\u0026quot;description\u0026quot; content=\u0026quot;这是一个HTML详解的网页\u0026quot;\u0026gt;。 keywords：网页的关键词列表，多个关键词用逗号分隔，如\u0026lt;meta name=\u0026quot;keywords\u0026quot; content=\u0026quot;HTML,详解,网页\u0026quot;\u0026gt;。 author：网页的作者信息，如\u0026lt;meta name=\u0026quot;author\u0026quot; content=\u0026quot;张三\u0026quot;\u0026gt;。 robots：用来告诉搜索引擎是否索引该页面及其链接，如\u0026lt;meta name=\u0026quot;robots\u0026quot; content=\u0026quot;index, follow\u0026quot;\u0026gt;表示允许索引和跟踪链接。 viewport：用于控制网页在移动设备上的显示和缩放行为，如\u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1.0\u0026quot;\u0026gt;表示网页宽度与设备宽度相同，初始缩放比例为1。 title \u0026lt;title\u0026gt;标签定义了网页的标题，这个标题会显示在浏览器的标签页上，也是搜索引擎结果中的标题。一个好的标题有助于吸引用户点击。\nlink \u0026lt;link\u0026gt;标签用于定义与文档相关的外部资源，如样式表、图标等。常见的用法包括： - 引入CSS样式表：\u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;styles.css\u0026quot;\u0026gt; - 定义网页图标：\u0026lt;link rel=\u0026quot;icon\u0026quot; type=\u0026quot;image/x-icon\u0026quot; href=\u0026quot;favicon.ico\u0026quot;\u0026gt;\nstyle \u0026lt;style\u0026gt;标签用于定义文档的内部样式，通常包含CSS代码。与\u0026lt;link\u0026gt;标签不同，\u0026lt;style\u0026gt;标签直接在HTML文档中定义样式，而不是引用外部样式表。css的引用方式有三种，分别是内联样式、内部样式和外部样式，\u0026lt;style\u0026gt;标签属于内部样式。本本就不详细介绍css的内容，这里只做简单说明。\nbody \u0026lt;body\u0026gt;标签包含了网页的主要内容，这些内容会直接显示在浏览器中。所有可见的网页元素，如文本、图像、链接、表格等，都必须包含在\u0026lt;body\u0026gt;标签内。\n语义化标签 在之前的HTML 基础知识入门文章中我已经介绍了HTML的基本标签，所以在本文就不再赘述。在HTML5中引入的语义化标签，这是HTML5的重要特性，下面我将介绍一些常用的HTML语义化标签：\nheader：定义文档或节的头部区域，通常包含标题、导航链接等内容。 nav：定义导航链接的区域，通常包含网站的主要导航菜单。 main：定义文档的主要内容区域，通常包含页面的核心内容。 section：定义文档中的一个独立区域，通常包含相关内容的集合。 article：定义独立的内容块，如博客文章、新闻报道等。 aside：定义与主内容相关的侧边栏内容，如广告、推荐文章等。 footer：定义文档或节的底部区域，通常包含版权信息、联系信息等内容。 使用语义化标签有助于提高网页的可读性和可维护性，同时也有助于搜索引擎优化(SEO)和辅助技术的支持。\n块级元素与行内/行内块 在HTML中，元素可以分为块级元素(block-level elements)和行内元素(inline elements)以及行内块元素(inline-block elements)三大类。这两类元素在网页布局和显示方式上有显著的区别。\n块级元素 块级元素通常会占据其父元素的整个宽度，并且在其前后会自动换行。块级元素可以包含其他块级元素和行内元素。常见的块级元素有： - \u0026lt;div\u0026gt;：用于定义一个容器，可以包含其他元素。 - \u0026lt;p\u0026gt;：用于定义段落。 - \u0026lt;h1\u0026gt;至\u0026lt;h6\u0026gt;：用于定义标题，\u0026lt;h1\u0026gt;表示最高级别的标题，\u0026lt;h6\u0026gt;表示最低级别的标题。 - \u0026lt;ul\u0026gt;和\u0026lt;ol\u0026gt;：用于定义无序列表和有序列表。 - \u0026lt;li\u0026gt;：用于定义列表项。 - \u0026lt;table\u0026gt;：用于定义表格。\n行内元素 行内元素不会占据整个宽度，只会占据其内容所需的宽度，并且不会在其前后换行。行内元素通常只能包含文本或其他行内元素。常见的行内元素有： - \u0026lt;span\u0026gt;：用于定义一个行内容器，可以包含文本或其他行内元素。 - \u0026lt;a\u0026gt;：用于定义超链接。 - \u0026lt;strong\u0026gt;：用于定义重要的文本，通常以粗体显示。 - \u0026lt;em\u0026gt;：用于定义强调的文本，通常以斜体显示。 - \u0026lt;img\u0026gt;：用于嵌入图像。\n行内块元素 行内块元素结合了块级元素和行内元素的特性，它们在文档流中表现为行内元素，但可以设置宽度和高度。常见的行内块元素有： - \u0026lt;button\u0026gt;：用于定义按钮。 - \u0026lt;input\u0026gt;：用于定义输入字段。 - \u0026lt;label\u0026gt;：用于定义表单控件的标签。\n嵌套与转换 块级元素和行内元素可以嵌套使用，但需要遵循一定的规则。例如，块级元素不能嵌套在行内元素内，而行内元素可以嵌套在块级元素内。块级元素和行内元素之间也可以转化，例如通过CSS的display属性将块级元素设置为行内元素，反之亦然。\n将块级元素转化为行内元素：\n1 2 3 div { display: inline; } 将行内元素转化为块级元素：\n1 2 3 span { display: block; } 把元素设置为行内块元素：\n1 2 3 button { display: inline-block; } 媒体与图形 多媒体元素 HTML5引入了多媒体元素，使得在网页中嵌入音频和视频可以不再依赖外部插件。下面我将介绍HTML中的多媒体元素：\naudio 用于在网页中嵌入音频文件。常见的属性有src(指定音频文件的URL)、controls(显示音频控件)、autoplay(自动播放音频)、loop(循环播放音频)等。例如：\n1 \u0026lt;audio src=\u0026#34;audio.mp3\u0026#34; controls\u0026gt;\u0026lt;/audio\u0026gt; video 用于在网页中嵌入视频文件。常见的属性有src(指定视频文件的URL)、controls(显示视频控件)、autoplay(自动播放视频)、loop(循环播放视频)、width和height(指定视频的宽度和高度)等。例如：\n1 \u0026lt;video src=\u0026#34;video.mp4\u0026#34; controls width=\u0026#34;600\u0026#34; height=\u0026#34;400\u0026#34;\u0026gt;\u0026lt;/video\u0026gt; source 用于为\u0026lt;audio\u0026gt;和\u0026lt;video\u0026gt;元素提供多个媒体资源，以便浏览器选择支持的格式。例如：\n1 2 3 4 5 \u0026lt;video controls width=\u0026#34;600\u0026#34; height=\u0026#34;400\u0026#34;\u0026gt; \u0026lt;source src=\u0026#34;video.mp4\u0026#34; type=\u0026#34;video/mp4\u0026#34;\u0026gt; \u0026lt;source src=\u0026#34;video.webm\u0026#34; type=\u0026#34;video/webm\u0026#34;\u0026gt; 您的浏览器不支持视频播放。 \u0026lt;/video\u0026gt; Canvas 与 SVG HTML5引入了\u0026lt;canvas\u0026gt;和\u0026lt;svg\u0026gt;元素，用于在网页中绘制图形和矢量图形,。\ncanvas \u0026lt;canvas\u0026gt;元素用于在网页中绘制位图图形。它提供了一个绘图区域，可以通过JavaScript使用Canvas API进行绘图操作。常见的属性有width和height(指定画布的宽度和高度)。例如：\n1 2 3 4 5 6 7 \u0026lt;canvas id=\u0026#34;myCanvas\u0026#34; width=\u0026#34;600\u0026#34; height=\u0026#34;400\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; \u0026lt;script\u0026gt; let canvas = document.getElementById(\u0026#34;myCanvas\u0026#34;); let ctx = canvas.getContext(\u0026#34;2d\u0026#34;); ctx.fillStyle = \u0026#34;red\u0026#34;; ctx.fillRect(0, 0, 600, 400); \u0026lt;/script\u0026gt; getContext(\u0026quot;2d\u0026quot;)方法用于获取2D绘图上下文，可以使用该上下文对象进行绘图操作。 fillStyle属性用于设置填充颜色。 fillRect(x, y, width, height)方法用于绘制一个填充矩形。 svg \u0026lt;svg\u0026gt;元素用于在网页中嵌入可缩放矢量图形。SVG是一种基于XML的图形格式，可以通过SVG标签和属性定义图形元素。常见的SVG元素有\u0026lt;circle\u0026gt;(圆形)、\u0026lt;rect\u0026gt;(矩形)、\u0026lt;line\u0026gt;(直线)、\u0026lt;path\u0026gt;(路径)等。例如：\n1 2 3 \u0026lt;svg width=\u0026#34;600\u0026#34; height=\u0026#34;400\u0026#34;\u0026gt; \u0026lt;circle cx=\u0026#34;300\u0026#34; cy=\u0026#34;200\u0026#34; r=\u0026#34;100\u0026#34; fill=\u0026#34;blue\u0026#34; /\u0026gt; \u0026lt;/svg\u0026gt; cx和cy属性指定圆心的坐标。 r属性指定圆的半径。 fill属性指定填充颜色。 因为canvas和svg的内容较多且涉及的知识较复杂,在本文就不再详细介绍,后续我会单独写文章进行讲解。\n浏览器能力：存储与实时通信 本地存储与会话存储 HTML5引入了本地存储(Local Storage)和会话存储(Session Storage)两种机制，用于在用户浏览器中存储数据。这些存储机制允许网页在用户关闭浏览器后仍然保留数据，提供更好的用户体验。下面我将介绍HTML5的本地存储：\n本地存储(Local Storage) 本地存储允许网页在用户浏览器中存储数据，数据没有过期时间，除非用户手动清除，否则数据会一直保留。常用的方法有： - localStorage.setItem(key, value)：存储数据。 - localStorage.getItem(key)：获取数据。 - localStorage.removeItem(key)：删除数据。 - localStorage.clear()：清空所有数据。\n1 2 3 4 5 6 7 8 9 10 11 12 // 存储数据 localStorage.setItem(\u0026#34;username\u0026#34;, \u0026#34;张三\u0026#34;); // 获取数据 let username = localStorage.getItem(\u0026#34;username\u0026#34;); console.log(username); // 输出: 张三 // 删除数据 localStorage.removeItem(\u0026#34;username\u0026#34;); // 清空所有数据 localStorage.clear(); 会话存储(Session Storage) 会话存储与本地存储类似，但数据只在当前浏览器会话中保留，关闭浏览器窗口或标签页后数据会被清除。常用的方法与本地存储相同： - sessionStorage.setItem(key, value)：存储数据。 - sessionStorage.getItem(key)：获取数据。 - sessionStorage.removeItem(key)：删除数据。 - sessionStorage.clear()：清空所有数据。\n1 2 3 4 5 6 7 8 9 10 11 12 // 存储数据 sessionStorage.setItem(\u0026#34;username\u0026#34;, \u0026#34;张三\u0026#34;); // 获取数据 let username = sessionStorage.getItem(\u0026#34;username\u0026#34;); console.log(username); // 输出: 张三 // 删除数据 sessionStorage.removeItem(\u0026#34;username\u0026#34;); // 清空所有数据 sessionStorage.clear(); Web Workers 与 WebSockets HTML5引入了Web Workers和WebSockets两种技术，用于提升网页的性能和实时通信能力,这也是HTML5的重要特性之一。\nWeb Workers Web Workers允许网页在后台线程中运行JavaScript代码，从而避免阻塞主线程，提高网页的响应速度。常用的方法有： - 创建Worker：let worker = new Worker(\u0026quot;worker.js\u0026quot;)。 - 发送消息：worker.postMessage(data)。 - 接收消息：worker.onmessage = function(event) { ... }。 - 终止Worker：worker.terminate()。\n1 2 3 4 5 6 7 8 9 10 11 // main.js let worker = new Worker(\u0026#34;worker.js\u0026#34;); worker.postMessage(\u0026#34;Hello, Worker!\u0026#34;); worker.onmessage = function(event) { console.log(\u0026#34;Received from worker: \u0026#34; + event.data); }; // worker.js onmessage = function(event) { let result = event.data + \u0026#34; - Processed by Worker\u0026#34;; postMessage(result); }; WebSockets WebSockets提供了一种在客户端和服务器之间进行双向通信的机制，允许实时数据传输。常用的方法有： - 创建WebSocket连接：let socket = new WebSocket(\u0026quot;ws://example.com/socket\u0026quot;)。 - 发送消息：socket.send(data)。 - 接收消息：socket.onmessage = function(event) { ... }。 - 关闭连接：socket.close()。\n1 2 3 4 5 6 7 8 9 10 let socket = new WebSocket(\u0026#34;ws://example.com/socket\u0026#34;); socket.onopen = function(event) { socket.send(\u0026#34;Hello, Server!\u0026#34;); }; socket.onmessage = function(event) { console.log(\u0026#34;Received from server: \u0026#34; + event.data); }; socket.onclose = function(event) { console.log(\u0026#34;WebSocket connection closed.\u0026#34;); }; Web Workers和WebSockets的内容较多且涉及的知识较复杂,在本文就不再详细介绍,后续我会单独写文章进行讲解。\n结语 HTML构成了Web世界的一砖一瓦，是每个前端开发都必须掌握的基础知识。HTML看似简单，实际上可深挖的内容很多，本文也并不能涵盖所有细节，所以有些知识需要自己去学习，在一些公司的面试中也会问到关于HTML的相关问题，所以掌握好HTML是非常有必要的。\n参考资料 MDN Web Docs - HTML 『HTML』详解head标签 2024前端高频面试题\u0026ndash; HTML篇 前端高频考题（html） ","date":"2025-10-28T16:37:06+08:00","permalink":"https://adam-code-line.github.io/p/dtails-for-html/","title":"HTML详解"},{"content":"vue中组件之间传值的八种方式 前言 在Vue开发中，组件之间的通信是一个常见的需求。本文将介绍几种常用的组件通信方式，包括props和$emit事件、provide/inject、自定义事件总线、Vuex状态管理、v-model、透传 Attributes、插槽 Slots。\nProps 和 $emit(事件) Props和$emit是Vue中最基本的组件通信方式。父组件通过props向子组件传递数据，子组件通过$emit触发事件向父组件传递数据。\n1.Props传值：\n首先子组件要显式声明它所接收的props，这样 Vue 才能知道外部传入的哪些是 props，哪些是透传 attribute：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // ChildComponent.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{ message }}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; //此处是TypeScript的写法，使用类型标注来声明 props const props = defineProps\u0026lt;{ message?: string; }\u0026gt;(); //可以使用对象的形式来声明 props ，也可以使用字符串数组的形式 const props = defineProps([\u0026#39;message\u0026#39;]); \u0026lt;/script\u0026gt; 然后父组件可以通过props向子组件传递数据：\n1 2 3 4 5 6 7 8 // ParentComponent.vue \u0026lt;template\u0026gt; \u0026lt;ChildComponent message=\u0026#34;Hello from Parent!\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import ChildComponent from \u0026#39;./ChildComponent.vue\u0026#39;; \u0026lt;/script\u0026gt; 2.$emit传值：\n子组件通过$emit触发事件向父组件传递数据：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // ChildComponent.vue \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;sendMessage\u0026#34;\u0026gt;Send Message\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { defineEmits } from \u0026#39;vue\u0026#39;; //定义子组件可以触发的事件及其参数类型 const emit = defineEmits\u0026lt;{ (event: \u0026#39;message\u0026#39;, payload: string): void; }\u0026gt;(); //触发事件并传递数据 function sendMessage() { emit(\u0026#39;message\u0026#39;, \u0026#39;Hello from Child!\u0026#39;); } \u0026lt;/script\u0026gt; 父组件监听子组件触发的事件并接收数据：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // ParentComponent.vue \u0026lt;template\u0026gt; \u0026lt;ChildComponent @message=\u0026#34;handleMessage\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import ChildComponent from \u0026#39;./ChildComponent.vue\u0026#39;; function handleMessage(payload: string) { console.log(\u0026#39;Received message from child:\u0026#39;, payload); } //控制台打印：Received message from child: Hello from Child! \u0026lt;/script\u0026gt; Provide/Inject Provide/Inject 是 Vue 3 中提供的一种跨级组件通信方式，允许祖先组件向后代组件传递数据，而不需要通过中间组件逐层传递,父组件可以通过provide选项提供数据，子组件（包括跨层级的子孙组件）可以通过inject选项注入这些数据，这样也可以避免props的逐层传递。\n1. Provide 提供数据：\n1 2 3 4 5 6 7 8 9 10 11 12 // GrandParentComponent.vue \u0026lt;template\u0026gt; \u0026lt;ParentComponent /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import ParentComponent from \u0026#39;./ParentComponent.vue\u0026#39;; import { provide } from \u0026#39;vue\u0026#39;; provide(\u0026#39;message\u0026#39;, \u0026#39;Hello from Grandparent!\u0026#39;); \u0026lt;/script\u0026gt; 也可在整个应用层面提供依赖\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // App.vue \u0026lt;template\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { createApp } from \u0026#39;vue\u0026#39; const app = createApp({}) app.provide(/* 注入名 */ \u0026#39;message\u0026#39;, /* 值 */ \u0026#39;hello!\u0026#39;) \u0026lt;/script\u0026gt; 2. Inject 注入数据：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // ChildComponent.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{ message }}\u0026lt;/div\u0026gt;//显示Hello from Grandparent! \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { inject } from \u0026#39;vue\u0026#39;; const message = inject(\u0026#39;message\u0026#39;); //如果有多个父组件提供了相同键的数据，注入将解析为组件链上最近的父组件所注入的值 \u0026lt;/script\u0026gt; Provide和Inject需要一起使用，适用于跨多层组件传递数据的场景，避免了props的逐层传递，需要注意的是provide和inject绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。\n自定义事件总线 自定义事件总线是一种轻量级的组件通信方式，适用于非父子关系的组件之间的通信。可以使用一个空的Vue实例作为事件总线，通过$emit和$on方法实现组件间的通信。\n1. 创建事件总线：\n1 2 3 // eventBus.ts import { createApp } from \u0026#39;vue\u0026#39;; export const eventBus = createApp({}); 2. 组件间通信：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // ComponentA.vue \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;sendMessage\u0026#34;\u0026gt;Send Message to B\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { eventBus } from \u0026#39;./eventBus\u0026#39;; function sendMessage() { eventBus.emit(\u0026#39;message\u0026#39;, \u0026#39;Hello from A!\u0026#39;); } \u0026lt;/script\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // ComponentB.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{ message }}\u0026lt;/div\u0026gt;//显示Hello from A! \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { eventBus } from \u0026#39;./eventBus\u0026#39;; const message = ref(\u0026#39;\u0026#39;); eventBus.on(\u0026#39;message\u0026#39;, (payload: string) =\u0026gt; { message.value = payload; }); \u0026lt;/script\u0026gt; Vuex 状态管理 Vuex 是 Vue.js 官方提供的状态管理库，适用于大型应用中复杂的组件通信需求。通过集中管理应用的状态，可以实现跨组件的数据共享和状态同步。\n1. 安装 Vuex：\n1 2 npm install vuex@next 2. 创建 Vuex Store：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // store/index.ts import { createStore } from \u0026#39;vuex\u0026#39;; const store = createStore({ state() { return { message: \u0026#39;Hello from Vuex!\u0026#39; }; }, mutations: { setMessage(state, payload) { state.message = payload; } } }); export default store; 3. 在组件中使用 Vuex：\n1 2 3 4 5 6 7 8 9 10 11 // Component.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{ message }}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { useStore } from \u0026#39;vuex\u0026#39;; const store = useStore(); const message = computed(() =\u0026gt; store.state.message); \u0026lt;/script\u0026gt; V-Model 双向绑定 v-model 是 Vue 提供的双向数据绑定语法糖，适用于父子组件之间的数据同步。通过在子组件中使用modelValue和update:modelValue事件，可以实现父组件和子组件之间的双向绑定。\n1. 子组件使用 v-model：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // ChildComponent.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;Parent bound v-model is: {{ model }}\u0026lt;/div\u0026gt; //这里的`model`会随着父组件的变化而变化，实现了双向绑定。 \u0026lt;button @click=\u0026#34;update\u0026#34;\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; //从 Vue3.4开始，推荐的实现方式是使用 defineModel()宏 const model = defineModel() function update() { model.value++ } \u0026lt;/script\u0026gt; 2. 父组件使用 v-model：\n1 2 3 4 5 6 7 8 9 10 11 12 // ParentComponent.vue \u0026lt;template\u0026gt; \u0026lt;ChildComponent v-model=\u0026#34;parentValue\u0026#34; /\u0026gt; \u0026lt;div\u0026gt;Parent value is: {{ parentValue }}\u0026lt;/div\u0026gt; //这里的`parentValue`会随着子组件的更新而变化，实现了双向绑定。 \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { ref } from \u0026#39;vue\u0026#39;; import ChildComponent from \u0026#39;./ChildComponent.vue\u0026#39;; const parentValue = ref(0); \u0026lt;/script\u0026gt; defineModel需要 Vue 3.4 及以上版本支持,它的底层机制是通过props和$emit事件实现的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // ChildComponent.vue \u0026lt;template\u0026gt; \u0026lt;input :value=\u0026#34;modelValue\u0026#34; @input=\u0026#34;event =\u0026gt; emit(\u0026#39;update:modelValue\u0026#39;, event.target.value)\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; const props = defineProps\u0026lt;{ modelValue: number; }\u0026gt;(); const emit = defineEmits\u0026lt;{ (event: \u0026#39;update:modelValue\u0026#39;, payload: number): void; //ts类型标注，声明子组件可以触发的事件及其参数类型 }\u0026gt;(); \u0026lt;/script\u0026gt; 然后在父组件中v-model = \u0026quot;parentValue\u0026quot;将会被编译成：\n1 2 3 4 5 // ParentComponent.vue \u0026lt;template\u0026gt; \u0026lt;ChildComponent :modelValue=\u0026#34;parentValue\u0026#34; @update:modelValue=\u0026#34;$event =\u0026gt; (parentValue = $event)\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; 透传 Attributes 透传 attributes 是指传递给子组件，却没有在子组件中显式声明为 props 或 emits 的 attribute或 v-on事件监视器，最常见的是class、style和id。这些属性会被自动添加到子组件的根元素上，适用于需要传递大量属性但不想逐一声明的场景。\n1. 透传 Attributes 示例：\n1 2 3 4 5 6 7 8 9 10 // ChildComponent.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;Child Component\u0026lt;/div\u0026gt; //如果已经有了class、style或id属性，这些属性会和从父组件继承的值合并 \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; //子组件没有显式声明任何 props 或 emits \u0026lt;/script\u0026gt; 1 2 3 4 5 6 7 8 9 // ParentComponent.vue \u0026lt;template\u0026gt; \u0026lt;ChildComponent class=\u0026#34;custom-class\u0026#34; style=\u0026#34;color: red;\u0026#34; id=\u0026#34;child-component\u0026#34; /\u0026gt; //父组件传递的 class、style 和 id 会被自动添加到子组件的根元素上 \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import ChildComponent from \u0026#39;./ChildComponent.vue\u0026#39;; \u0026lt;/script\u0026gt; 最后渲染的结果：\n1 2 3 4 \u0026lt;div id=\u0026#34;child-component\u0026#34; class=\u0026#34;custom-class\u0026#34; style=\u0026#34;color: red;\u0026#34;\u0026gt; Child Component \u0026lt;/div\u0026gt; 禁用透传 Attributes 有时我们可能不希望某些属性被透传到子组件，这时可以使用 inheritAttrs: false 选项来禁用透传。\n1 2 3 4 5 6 7 8 9 10 // ChildComponent.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;Child Component\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; defineOptions({ inheritAttrs: false }); \u0026lt;/script\u0026gt; 当子组件有多个根元素时，Vue 默认会将透传的属性添加到第一个根元素上，这可能不是我们想要的效果。通过禁用透传，我们可以手动将属性绑定到特定的元素上。\n1 2 3 4 5 6 7 8 9 10 11 12 // ChildComponent.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;First Root Element\u0026lt;/div\u0026gt; \u0026lt;div v-bind=\u0026#34;$attrs\u0026#34;\u0026gt;Second Root Element with inherited attributes\u0026lt;/div\u0026gt; //将透传的属性绑定到第二个根元素上 \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; defineOptions({ inheritAttrs: false }); \u0026lt;/script\u0026gt; 注意：没有参数的v-bind会将一个对象的所有属性都作为attribute应用到目标元素上。\n多根节点的透传 多根节点的组件没有自动attribute透传功能，如果$attrs没有被显式绑定，将会抛出一个运行时的警告。\n1 2 3 4 5 6 7 8 // MultiRootComponent.vue \u0026lt;template\u0026gt; \u0026lt;header\u0026gt;First Root Element\u0026lt;/header\u0026gt; \u0026lt;footer\u0026gt;Second Root Element\u0026lt;/footer\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; //没有显式绑定 $attrs，会抛出警告 \u0026lt;/script\u0026gt; 要解决这个问题，可以显式绑定$attrs到其中一个根元素上：\n1 2 3 4 5 6 7 // MultiRootComponent.vue \u0026lt;template\u0026gt; \u0026lt;header v-bind=\u0026#34;$attrs\u0026#34;\u0026gt;First Root Element with inherited attributes\u0026lt;/header\u0026gt; \u0026lt;footer\u0026gt;Second Root Element\u0026lt;/footer\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; \u0026lt;/script\u0026gt; 插槽 Slots 插槽（Slots）是Vue中用于组件间传递内容的一种机制，允许父组件向子组件传递任意的模板内容。插槽适用于需要在子组件中动态渲染父组件提供的内容的场景。\n1. 基本插槽\n1 2 3 4 5 6 7 8 9 // ChildComponent.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; //插槽占位符 \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; \u0026lt;/script\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 // ParentComponent.vue \u0026lt;template\u0026gt; \u0026lt;ChildComponent\u0026gt; \u0026lt;p\u0026gt;This is content passed from Parent to Child via slot.\u0026lt;/p\u0026gt; //传递给子组件的内容,会渲染在子组件的插槽位置 \u0026lt;/ChildComponent\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import ChildComponent from \u0026#39;./ChildComponent.vue\u0026#39;; \u0026lt;/script\u0026gt; 具名插槽 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // ChildComponent.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;header\u0026gt; \u0026lt;slot name=\u0026#34;header\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; //具名插槽 \u0026lt;/header\u0026gt; \u0026lt;main\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; //默认插槽 \u0026lt;/main\u0026gt; \u0026lt;footer\u0026gt; \u0026lt;slot name=\u0026#34;footer\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; //具名插槽 \u0026lt;/footer\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; \u0026lt;/script\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // ParentComponent.vue \u0026lt;template\u0026gt; \u0026lt;ChildComponent\u0026gt; \u0026lt;template #header\u0026gt;//使用含v-slot的\u0026lt;template\u0026gt;元素，并将插槽的名字传给该指令，此处是语法糖，等同于v-slot:header \u0026lt;h1\u0026gt;This is the header content.\u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;p\u0026gt;This is the main content.\u0026lt;/p\u0026gt; \u0026lt;template #footer\u0026gt; \u0026lt;p\u0026gt;This is the footer content.\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/ChildComponent\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import ChildComponent from \u0026#39;./ChildComponent.vue\u0026#39;; \u0026lt;/script\u0026gt; 条件插槽 根据内容是否被传入了插槽来渲染某些内容,可以使用$slots和v-if来实现条件插槽：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // ChildComponent.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;header v-if=\u0026#34;$slots.header\u0026#34;\u0026gt; \u0026lt;slot name=\u0026#34;header\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;main\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;footer v-if=\u0026#34;$slots.footer\u0026#34;\u0026gt; \u0026lt;slot name=\u0026#34;footer\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/footer\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; \u0026lt;/script\u0026gt; 动态插槽 1 2 3 4 5 6 7 8 9 10 11 // ParentComponent.vue \u0026lt;base-layout\u0026gt; \u0026lt;template v-slot:[dynamicSlotName]\u0026gt; ... \u0026lt;/template\u0026gt; \u0026lt;!-- 缩写为 --\u0026gt; \u0026lt;template #[dynamicSlotName]\u0026gt; ... \u0026lt;/template\u0026gt; \u0026lt;/base-layout\u0026gt; 在上面的例子中，dynamicSlotName是一个动态变量，可以根据需要传递不同的插槽名称，实现更灵活的插槽内容传递。\n作用域插槽 作用域插槽（Scoped Slots）是指插槽可以接收来自子组件的数据，并将这些数据传递给插槽的内容。通过作用域插槽，父组件可以更灵活地控制插槽的渲染内容。\n1 2 3 4 5 6 7 8 9 // ChildComponent.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;slot :data=\u0026#34;slotData\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; //将数据传递给插槽 \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; const slotData = { message: \u0026#39;Hello from ChildComponent!\u0026#39; }; \u0026lt;/script\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 // ParentComponent.vue \u0026lt;template\u0026gt; \u0026lt;ChildComponent\u0026gt; \u0026lt;template #default=\u0026#34;{ data }\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ data.message }}\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/ChildComponent\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import ChildComponent from \u0026#39;./ChildComponent.vue\u0026#39;; \u0026lt;/script\u0026gt; 在上面的例子中，子组件通过slot将slotData对象传递给插槽内容，父组件通过作用域插槽接收这个数据并进行渲染。\n注意：在 Vue 3 中，作用域插槽的语法有所简化，可以直接在template标签上使用#default来定义默认插槽(最好使用显示的默认插槽防止歧义，即使用\u0026lt;template #default\u0026gt;)，并通过解构语法获取传递的数据。\n结论 本文介绍了八种常用的Vue组件通信方式，根据具体的应用场景和需求，选择合适的通信方式可以提高代码的可维护性和可读性。Vue组件传参的方式多种多样，本文只介绍了几种常见的方法，实际可以有更多的变通和组合使用，灵活运用这些技术可以帮助开发者更好地管理组件之间的通信。\n参考资料 Vuex 官方文档 ","date":"2025-10-24T13:52:42+08:00","permalink":"https://adam-code-line.github.io/p/component-communication-in-vue/","title":"vue中组件之间传值的八种方式"},{"content":"前端开发扫盲 本文的目的是帮助零基础的读者了解前端开发的基本概念和技术栈，扫除入门障碍，为进一步学习打下坚实基础。本文也会回答“前端是什么”“前端开发需要掌握哪些核心技术”等基本问题，也希望能破除一些同学对前端的误解。\n对前端的错误认知 介绍前端之前，先来澄清一些对前端的常见误解：\n前端只是网页设计的 有一些程序员开玩笑会戏称写前端的都是\u0026quot;切图仔\u0026quot;或者\u0026quot;美工\u0026quot;(确实有一点)，但实际上现代的前端开发基本已经基本不再负责视觉设计，该部分工作一般会交给UI设计师来完成。\n前端不需要编程 这种误解虽然罕见(其实我自己没见有人讲过)，但是确实有人认为前端的工作并不涉及多少编程甚至不需要编程，实际上前端开发需要掌握多种编程语言和技术，如 HTML、CSS 和 JavaScript，这些都是前端基础,而且前端开发的工作中也会涉及到一些编程逻辑和算法,尤其是是在学习框架之后的组件间的交互和Hook的使用等会让人感到十分痛苦(这是真的)。\n前端开发很简单 虽然入门相对容易，但前端开发的深度和广度都很大，要成为一名优秀的前端开发者，需要深入理解各种技术和工具，尤其是到中后期学习框架的时候，需要深入学习框架的规范和各种使用方法，学习难度相对比较大。\n前端和后端是完全独立的 前端和后端是相互依赖的，前端需要与后端协作，确保数据的正确传输和处理，在一些工作中可能会涉及到后端的知识，也会有全栈开发的情况,在一些小型公司会让你把前后端的事都干完，甚至连网络安全的问题都会来找你(这是某人亲身经历)。\n什么是前端？ 要回答“前端是什么”,得先说说前端的概念,前端(Front-end)是网站前台部分，指运行在PC端、移动端等浏览器上并直接展现给用户浏览并提供给用户交互的网页界面。换句话说，你在网站或应用程序的屏幕上能看到的所有内容都属于前端。你访问的网站的图片、文字、可点击的按钮、导航栏等，以及你在手机上看到的应用界面，用手势放大缩小的图片，播放的视频等，都是前端的一部分。前端开发就是在构建所有的这些内容和功能，也即创造了你在屏幕上看到的外观和触摸到的体验。且前端开发的职能不仅仅是实现可视的交互界面，还需要将软件工程的原理和方法使用到开发中，也即前端工程化。\n前端开发的职责 前端开发的主要职责包括以下几个方面：\n用户界面的实现：前端开发者负责将设计师提供的视觉设计稿转化为实际可用的网页界面。 响应式设计：确保网页在不同设备和屏幕尺寸上都能良好显示和操作，提供一致的用户体验。 交互功能开发：通过编写代码实现网页的交互功能，如按钮点击、表单提交、动态内容更新等，使用户能够与网页进行互动。 性能优化：前端开发者需要优化网页的加载速度和运行效率，提升用户体验。 跨浏览器兼容性：确保网页在不同浏览器上都能正常工作，解决浏览器差异带来的问题。 前端工程化：前端开发者需要使用自动化的构建工具(如webpack、Vite等)来处理和打包前端资源、版本控制工具(如Git)来管理代码和项目、包管理工具(如npm、yarn等)来提高开发效率，也需要使用模块化的开发模式，将代码拆分为更小的、易于管理的模块，有助于之后的复用、维护与扩展，还需要基于组件的思想构建用户界面,这些都是前端工程化的内容。 与后端协作：前端开发者需要与后端开发者紧密合作，确保前后端数据的正确传输和处理。 前端开发的过程 前端开发通常包括如下过程：\n产品和业务对接,需求敲定 每个项目的开始，都会有一个明确的需求梳理过程。首先是产品和业务团队的对接，产品经理会根据市场需求、用户反馈或者公司战略，提出相应的功能需求。这个阶段，前端团队通常需要和产品、设计、以及后端团队保持紧密沟通，确保功能需求和用户体验的一致性。\n需求评审，多方确认细节 产品需求整理后，会进行需求评审。这是一个非常重要的环节，前端、后端、测试等各方会一起参与。大家共同讨论需求的可行性、实现的技术方案、风险评估等，确保每个功能点都能得到合理的实现，同时避免后期出现大量返工。\n技术方案协商，前后端分工 需求评审后，前端团队会协商出相应的技术方案。前端需要根据需求来进行技术选型,确定要使用哪些框架和工具。\n排期和开发计划，确保时间有序 接下来，产品经理会根据项目的复杂程度和优先级，给出ddl，并明确开发阶段是否需要分批上线。在大厂中，开发进度通常需要精细化管理，确保每个环节按时完成。前端在排期中，通常会根据功能模块的大小、复杂度，以及人员的分配情况来评估开发时间。\n接口文档与开发，前端开始编码 前后端方案确定后，后端会提供接口文档，前端根据文档来进行开发。接口文档包含了每个接口的请求方式、参数说明、返回数据等信息。前端通过与后端提供的数据接口进行对接，开发出相应的页面或功能模块。在开发过程中，前端通常会使用版本控制工具（如Git）进行代码管理。\n测试用例评审与自测，确保质量 开发过程中，QA团队会准备相应的测试用例，确保每个功能点都经过充分的验证。前端开发完成后，通常会根据QA提供的冒烟用例进行自测，检查是否有明显的bug和问题。自测之后，前端会提交代码并进行提测。\n提测与修复Bug，保证稳定性 提交后，QA团队会进行更加全面的功能和性能测试，确保项目上线后没有明显问题。这个阶段，前端需要积极配合QA，查看反馈的bug并及时修复。通常情况下，开发和测试团队会在这一阶段共同处理大量的bug修复。\n上线，功能发布 当开发和测试都完成后，项目终于迎来了上线阶段。发布后会做最后的回归测试，确保没有遗漏任何关键问题。最终，项目顺利上线，并进行一些监控和跟踪，确保系统稳定运行。\n参考自大厂前端开发流程解析：从需求到上线全流程\n前端开发的核心技术 相比较与后端，前段的技术更迭要更为迅速，可能每一天都有新的前端框架和工具出现。尽管如此，前端开发的核心技术还是比较稳定的，主要包括以下三大核心技术，也被称为 前端三剑客 :\n⬇️ 下载 前端三剑客(出处:https://blog.csdn.net/askf01/article/details/132234956) HTML（超文本标记语言） HTML（HyperText Markup Language） 是构建网页的基础，用于定义网页的结构和内容。它使用标签来标识不同类型的内容，如标题、段落、链接、图像等。通俗点说，HTML负责网页的架构，是前端的\u0026quot;骨架\u0026quot;。\nHTML 的基本结构\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is a simple HTML document.\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在上面的例子中：\n\u0026lt;!DOCTYPE html\u0026gt; 声明文档类型，告诉浏览器这是一个 HTML5 文档。 \u0026lt;html\u0026gt; 标签是整个 HTML 文档的根元素，包含了所有其他元素。 \u0026lt;head\u0026gt; 标签包含了文档的元数据，如字符集、视口设置和标题。 \u0026lt;body\u0026gt; 标签包含了网页的可见内容，如标题和段落。 \u0026lt;h1\u0026gt; 标签表示一级标题，\u0026lt;p\u0026gt; 标签表示段落。 meta 标签用于提供关于 HTML 文档的信息，如字符编码和视口设置。 HTML 通过一系列的标签定义了网页中元素，比如哪个是标题，哪个是段落，哪里放图片，为前端搭建了基本的结构和内容。\nCSS（层叠样式表） CSS（Cascading Style Sheets） 用于控制网页的外观和布局。通过 CSS，开发者可以设置颜色、字体、间距、对齐方式等，使网页更具吸引力和可读性，也可以控制网页的布局，使得网页在不同的屏幕尺寸和设备上都能保持良好的视觉体验，也即响应式设计。简单的说，CSS 负责网页的样式、美化，是前端的\u0026quot;皮肤、衣服\u0026quot;。\nCSS 的基本用法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { background-color: #f0f0f0; font-family: Arial, sans-serif; } h1 { color: #333; } p { color: #666; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is a simple HTML document with CSS styling.\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在上面的例子中：\n\u0026lt;style\u0026gt; 标签用于在 HTML 文档中嵌入 CSS 样式。 body 选择器设置了网页的背景颜色和字体。 h1 选择器设置了标题的颜色。 p 选择器设置了段落的颜色。 font-family 属性定义了文本的字体样式。 background-color 属性设置了网页的背景颜色。 CSS 通过定义样式规则，调整网页的布局，修改元素的样式，实现丰富的视觉效果\nJavaScript JavaScript 是一种编程语言，用于为网页添加交互功能。通过 JavaScript，开发者可以实现动态内容更新、表单验证、动画效果等，使用户体验更加丰富，让网页不仅仅是静态的内容，而是可以响应用户的操作。总的来说，JavaScript 负责网页的交互，是前端的\u0026quot;动作\u0026quot;。\nJavaScript 的基本用法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { background-color: #f0f0f0; font-family: Arial, sans-serif; } h1 { color: #333; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;button onclick=\u0026#34;showMessage()\u0026#34;\u0026gt;Click Me\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; function showMessage() { alert(\u0026#34;Hello, World!\u0026#34;); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在上面的例子中：\n\u0026lt;script\u0026gt; 标签用于在 HTML 文档中嵌入 JavaScript 代码。 showMessage 函数定义了一个弹出消息的功能。 \u0026lt;button\u0026gt; 标签创建了一个按钮，onclick 属性绑定了点击事件，当按钮被点击时，会调用 showMessage 函数，弹出一个消息框。 JavaScript 通过编写脚本，实现网页的动态交互功能，让页面不仅仅是静态的内容，而是可以响应用户的操作。\n下图展示了前端三大核心技术各自的职责与关系：\n⬇️ 下载 前端三剑客职责与关系(出处:https://blog.csdn.net/weixin_46913665/article/details/124391067) 前端开发的常用工具和框架 除了上述核心技术外，前端开发还依赖于许多工具和框架来提高开发效率和代码质量。以下是一些常用的工具和框架：\n版本控制系统（如 Git） 用于跟踪代码的更改，协作开发和管理项目历史，在多人协作开发的环境中尤为重要。在开发过程也会使用到如 GitHub、Gitee代码托管平台来存储和管理代码仓库，这也是一个开发者必须掌握的技能。\n包管理器（如 npm、Yarn、pnpm） 用于管理项目依赖的库和工具，简化安装和更新过程,一般建议新手先使用npm,等到后面熟悉后可以尝试其他的包管理器。\n前端框架（如 React、Vue、Angular） 这些框架提供了结构化的方法来构建复杂的用户界面，简化开发过程，提高效率，框架的学习是一个长期的且比较困难的过程，需要等到对前端知识有一定的掌握后再深入学习。\n构建工具（如 Webpack、Vite） 用于打包和优化前端代码，提高加载速度和性能。关于构建工具的介绍我后面会单独写一篇文章来介绍。\n调试工具（如 Chrome DevTools） 用于调试和分析网页性能，帮助开发者快速定位和修复问题。\n本文重在介绍前端开发的基础知识，以上提到的工具和框架只是冰山一角，随着前端技术的发展，还有许多其他有用的工具和框架可供选择。\n学习路线 前端的学习路线可以看我之前写的[前端学习路线文章](../Learning path)。其实学习方式有多种多样，可以根据自己个人的情况来学习，不一定非得照着学习路线来学，但学习路线会给你们一个比较系统的学习思路，如果对怎么学习前端一无所知的同学还是建议照着学习路线来学。\n学习资源推荐 MDN Web Docs：全面的前端技术文档和教程。 黑马程序员前端入门视频：适合初学者的中文前端视频教程。 黑马程序员前端JavaScript入门到精通：系统学习JavaScript的中文视频教程。 结语 相较于后端，前端开发的上手难度要更为简单，学习了基本的 HTML、CSS 和 JavaScript 知识，就可以开始构建简单的网页，这也是为什么很多人说前端容易被取代的原因。但是如果想要成为一名优秀的前端开发者，还需要学习多种工具和框架的使用，并不断实践和积累经验。前端的知识体系庞大且更新迅速，保持学习的热情和持续的练习是不被淘汰的关键。希望本文能帮助你扫清前端开发的入门障碍，开启你的前端学习之旅！\n","date":"2025-10-19T14:18:40+08:00","permalink":"https://adam-code-line.github.io/p/frontend-development-basics/","title":"前端开发扫盲"},{"content":"Web API 前言 API（Application Programming Interface，应用程序编程接口）在软件程序开发中扮演着重要角色。本文将简单介绍什么是API，特别是Web API的概念、类型及其在前端开发中的简单应用。\n什么是API API是一组定义和协议，允许不同软件应用程序之间进行通信和交互。API抽象了复杂的代码，通过API，开发者可以直接使用已经封装好的代码功能，而无需从头开始编写代码功能的底层逻辑。\nWeb API的类型 Web API是通过HTTP协议进行通信的API，支持多种操作方式,并支持各种数据格式（如JSON、XML），它可以分成两大类： 浏览器API 和 第三方API。\n浏览器API 浏览器API是由浏览器提供的接口，允许开发者访问和操作浏览器的功能和资源。常见的浏览器API包括：\nDOM API：用于操作HTML和XML文档的结构、样式和内容。 Fetch API：用于发起网络请求，替代传统的XMLHttpRequest。 Canvas API：用于在网页上绘制图形和动画。 Geolocation API：用于获取用户的地理位置信息。 Web Storage API：用于在浏览器中存储数据（如localStorage和sessionStorage）。 WebSocket API：用于实现实时双向通信。 Media API：用于处理音频和视频内容。 第三方API 第三方API是由外部服务提供的接口，允许开发者访问这些服务的功能和数据。常见的第三方API包括：\n社交媒体API：如Facebook Graph API、Twitter API，用于访问社交媒体平台的数据和功能。 地图API：如Google Maps API、Mapbox API，用于集成地图和地理位置服务。 支付API：如Stripe API、PayPal API，用于处理在线支付。 天气API：如OpenWeatherMap API，用于获取天气信息。 数据API：如RESTful API、GraphQL API，用于访问各种数据服务。 3. 使用Web API的示例 使用JavaScript编写的简单示例，展示如何使用一些常见的Web API。\n使用Fetch API发起网络请求 1 2 3 4 fetch(\u0026#39;https://api.example.com/data\u0026#39;) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; console.log(data)) .catch(error =\u0026gt; console.error(\u0026#39;Error:\u0026#39;, error)); 使用Geolocation API获取用户位置 1 2 3 4 5 6 7 8 if (navigator.geolocation) { navigator.geolocation.getCurrentPosition(position =\u0026gt; { console.log(\u0026#39;Latitude:\u0026#39;, position.coords.latitude); console.log(\u0026#39;Longitude:\u0026#39;, position.coords.longitude); }); } else { console.log(\u0026#39;Geolocation is not supported by this browser.\u0026#39;); } 使用Canvas API绘制图形 1 2 3 4 const canvas = document.getElementById(\u0026#39;myCanvas\u0026#39;); const ctx = canvas.getContext(\u0026#39;2d\u0026#39;); ctx.fillStyle = \u0026#39;green\u0026#39;; ctx.fillRect(10, 10, 150, 100); 使用LocalStorage存储数据 1 2 3 4 5 6 7 8 9 // 存储数据 localStorage.setItem(\u0026#39;username\u0026#39;, \u0026#39;JohnDoe\u0026#39;); // 获取数据 const username = localStorage.getItem(\u0026#39;username\u0026#39;); console.log(username); // 输出: JohnDoe // 删除数据 localStorage.removeItem(\u0026#39;username\u0026#39;); // 清除所有数据 localStorage.clear(); 使用第三方API（以OpenWeatherMap为例） 1 2 3 4 fetch(\u0026#39;https://api.openweathermap.org/data/2.5/weather?q=London\u0026amp;appid=YOUR_API_KEY\u0026#39;) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; console.log(data)) .catch(error =\u0026gt; console.error(\u0026#39;Error:\u0026#39;, error)); 总结 Web API在现代前端开发中扮演着至关重要的角色。通过利用浏览器API和第三方API，开发者可以创建功能丰富、交互性强的Web应用程序。理解和掌握这些API的使用方法，将大大提升开发效率和用户体验。\n参考资料 MDN Web Docs - 客户端Web API What is an API? ","date":"2025-10-16T12:39:50+08:00","permalink":"https://adam-code-line.github.io/p/web-api/","title":"Web API"},{"content":"Nuxt 基础总述 前言 Nuxt 是一个基于 Vue.js 的开源全栈式框架，旨在简化服务端渲染（SSR）和静态网站生成（SSG）的开发过程。它提供了许多开箱即用的功能，如自动路由、状态管理、API 集成等，使开发者能够更专注于业务逻辑而非配置细节。\n1. Nuxt 的核心特性 服务端渲染（SSR）：提升首屏加载速度和 SEO 性能。 静态网站生成（SSG）：预渲染页面，适合内容驱动型网站。 自动路由：基于文件系统的路由，根据 pages/ 目录结构定义路由，无需手动配置。 自动导入：Nuxt 自动导入组件、组合式函数和 Vue.js API，以便在你的应用中无需显式导入即可使用。 TypeScript 支持：内置对 TypeScript 的支持，提升代码质量。 Vue 3 支持：兼容最新的 Vue 3 特性和生态。 组合式 API：支持 Vue 3 的组合式 API，提升代码复用性。 SEO 优化：内置对元标签和动态路由的支持，提升搜索引擎排名。 开发者工具：集成 Vue Devtools，提升调试体验。 支持多种渲染模式：如 SPA、SSR、SSG 和混合模式，满足不同项目需求。 强大的配置选项：通过 nuxt.config.js 文件灵活配置项目。 2. Nuxt 的安装与快速开始 创建项目 前置条件：\nNode.js（版本 20 及以上）,推荐使用LTS（长期支持）版本 npm 、yarn 或 pnpm 包管理器 文本编辑器（官方推荐 VSCode）配合官方Vue(Official)插件使用 终端 在终端创建项目：\n使用npm 、yarn 或 pnpm创建项目： 1 npm/yarn/pnpm create nuxt \u0026lt;project-name\u0026gt; 在VSCode中打开项目文件夹：\n1 code \u0026lt;project-name\u0026gt; 1 cd \u0026lt;project-name\u0026gt; 注意：\u0026lt;project-name\u0026gt; 替换为你的项目名称。\n运行项目 进入项目目录后，安装依赖并启动开发服务器：\n1 npm/yarn/pnpm run dev 打开浏览器访问 http://localhost:3000，即可看到 Nuxt 应用的欢迎页面。\n3. Nuxt 项目结构 Nuxt4官方项目结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 . ├── .nuxt/ # Nuxt 自动生成的文件夹 ├── .output/ # Nuxt 构建输出目录 ├── app/ │ ├── assets/ # 静态资源（CSS、图片等） │ ├── components/ # Vue 组件 │ ├── composables/ # 可复用的组合式函数 │ ├── layouts/ # 布局组件 │ ├── middleware/ # 中间件 │ ├── pages/ # 页面组件 │ ├── plugins/ # 插件 │ ├── utils/ # 工具函数 │ ├── app.vue/ # 根组件 │ ├── app.config.ts # 应用配置 │ └── error.vue # 错误页面组件 ├── content/ # 内容文件（如 Markdown） ├── modules/ # 公共模块 ├── node_modules/ # 依赖包 ├── public/ # 公共静态文件 ├── server/ # 服务器端代码（API 路由等） ├── shared/ # 共享代码 ├── .env # 环境变量文件 ├── .gitignore # Git 忽略文件 ├── .nuxtignore # Nuxt 忽略文件 ├── .nuxtrc # Nuxt 配置文件 ├── nuxt.config.ts # Nuxt 配置文件 ├── package.json # 项目配置文件 └── tsconfig.json # TypeScript 配置文件 4. Nuxt 的核心概念 页面与路由 在 pages/ 目录下创建 Vue 文件，Nuxt 会自动根据文件结构生成路由。例如：\n1 2 3 4 5 6 pages/ ├── index.vue # 路由：/ ├── about.vue # 路由：/about └── blog/ ├── index.vue # 路由：/blog └── [id].vue # 动态路由：/blog/:id 布局 布局组件位于 layouts/ 目录，用于定义应用的整体结构。默认布局文件为 default.vue，可以通过在页面组件中使用 definePageMeta 指定不同的布局：\n1 2 3 4 5 \u0026lt;script setup\u0026gt; definePageMeta({ layout: \u0026#39;custom\u0026#39; // 使用 layouts/custom.vue 作为布局 }) \u0026lt;/script\u0026gt; 组件 组件存放在 components/ 目录，可以在页面和布局中直接使用。Nuxt 支持自动导入组件，无需手动导入：\n1 2 3 \u0026lt;template\u0026gt; \u0026lt;MyComponent /\u0026gt; \u0026lt;/template\u0026gt; 组合式函数 组合式函数存放在 composables/ 目录，用于封装可复用的逻辑。例如：\n1 2 3 4 5 6 7 8 9 10 // composables/useCounter.ts export function useCounter() { //这里ref被nuxt自动导入 const count = ref(0); const increment = () =\u0026gt; { count.value++; }; return { count, increment }; } 插件 插件存放在 plugins/ 目录，用于扩展 Nuxt 功能。例如，注册第三方库：\n1 2 3 4 5 6 7 8 9 // plugins/axios.ts import axios from \u0026#39;axios\u0026#39;; export default defineNuxtPlugin(() =\u0026gt; { return { provide: { axios: axios.create({ baseURL: \u0026#39;https://api.example.com\u0026#39; }) } }; }); 中间件 中间件存放在 middleware/ 目录，用于在页面渲染前执行逻辑。例如，身份验证：\n1 2 3 4 5 6 7 // middleware/auth.ts export default defineNuxtRouteMiddleware((to, from) =\u0026gt; { const isAuthenticated = false; // 示例：实际应检查用户状态 if (!isAuthenticated \u0026amp;\u0026amp; to.path !== \u0026#39;/login\u0026#39;) { return navigateTo(\u0026#39;/login\u0026#39;); } }); 配置文件 nuxt.config.ts：项目的主要配置文件，用于配置模块、插件、路由等。 1 2 3 4 5 6 7 8 // nuxt.config.ts export default defineNuxtConfig({ modules: [\u0026#39;@nuxt/content\u0026#39;, \u0026#39;@nuxtjs/axios\u0026#39;], css: [\u0026#39;~/assets/css/main.css\u0026#39;], build: { transpile: [\u0026#39;some-dependency\u0026#39;] } }); runtimeConfig 用于存储运行时配置,可以将环境变量等值暴露给应用其他部分。默认情况下, runtimeConfig 中的值不会暴露给客户端,除非将其放在 public 对象中。\n1 2 3 4 5 6 7 export default defineNuxtConfig({ runtimeConfig: { public: { apiBase: process.env.API_BASE || \u0026#39;https://api.example.com\u0026#39; } } }); runtimeConfig 中的值可以通过 useRuntimeConfig 组合式函数访问，且可以通过环境变量(.env)覆盖：\n1 2 const config = useRuntimeConfig(); console.log(config.public.apiBase); // 访问公共配置 .env：环境变量文件，用于存储敏感信息，如 API 密钥。 1 2 API_BASE=https://api.example.com API_KEY=your_api_key_here tsconfig.json：TypeScript 配置文件。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;ESNext\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;ESNext\u0026#34;, \u0026#34;moduleResolution\u0026#34;: \u0026#34;Node\u0026#34;, \u0026#34;strict\u0026#34;: true, \u0026#34;jsx\u0026#34;: \u0026#34;preserve\u0026#34;, \u0026#34;esModuleInterop\u0026#34;: true, \u0026#34;skipLibCheck\u0026#34;: true, \u0026#34;forceConsistentCasingInFileNames\u0026#34;: true, \u0026#34;baseUrl\u0026#34;: \u0026#34;.\u0026#34;, \u0026#34;paths\u0026#34;: { \u0026#34;~/*\u0026#34;: [\u0026#34;./*\u0026#34;], \u0026#34;@/*\u0026#34;: [\u0026#34;./*\u0026#34;] }, \u0026#34;types\u0026#34;: [\u0026#34;@nuxt/types\u0026#34;, \u0026#34;@nuxtjs/axios\u0026#34;] }, \u0026#34;exclude\u0026#34;: [\u0026#34;node_modules\u0026#34;, \u0026#34;.nuxt\u0026#34;, \u0026#34;dist\u0026#34;] } package.json：项目依赖和脚本配置文件。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 { \u0026#34;name\u0026#34;: \u0026#34;my-nuxt-app\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;nuxt dev\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;nuxt build\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;nuxt start\u0026#34;, \u0026#34;generate\u0026#34;: \u0026#34;nuxt generate\u0026#34; }, \u0026#34;dependencies\u0026#34;: { \u0026#34;nuxt\u0026#34;: \u0026#34;^4.0.0\u0026#34;, \u0026#34;@nuxt/content\u0026#34;: \u0026#34;^2.0.0\u0026#34;, \u0026#34;@nuxtjs/axios\u0026#34;: \u0026#34;^5.13.6\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;typescript\u0026#34;: \u0026#34;^4.5.4\u0026#34; } } app.config.ts：应用程序配置文件，用于暴露构建时可确定的公共变量。 1 2 3 4 5 6 7 8 9 10 11 // app/app.config.ts export default defineAppConfig({ title: \u0026#39;Hello Nuxt\u0026#39;, theme: { dark: true, colors: { primary: \u0026#39;#ff0000\u0026#39;, secondary: \u0026#39;#00ff00\u0026#39;, } } }) app.config.ts 中的配置可以通过 useAppConfig 组合式函数访问，但与runtimeConfig 中的配置不同，app.config.ts 中的配置在构建时是静态的，而 runtimeConfig 中的配置可以在运行时动态变化，且app.config.ts中的变量不可以通过环境变量(.env)覆盖。\n1 2 const appConfig = useAppConfig(); console.log(appConfig.title); // 访问应用标题 5. 总结 Nuxt 是一个功能强大的全栈式框架，十分适合用于构建现代 Web 应用,但Nuxt中有着许多约定俗成的规则，需要花费时间去熟悉和掌握，具有一定的学习成本。通过本文的介绍，希望你对 Nuxt 有了一个初步的了解，能够开始使用它来构建你的下一个项目。\n6. 参考资料 Nuxt 官方文档 Vue.js 官方文档 TypeScript 官方文档 Vite 官方文档 Node.js 官方文档 ","date":"2025-10-12T11:51:13+08:00","permalink":"https://adam-code-line.github.io/p/nuxt/","title":"Nuxt 基础总述"},{"content":"JavaScript 基础知识入门 前言 JavaScript 是一种广泛用于网页开发的编程语言。本文将介绍 JavaScript 的基本概念、语法及其应用，帮助初学者快速入门。\n1. JavaScript 基本概念 JavaScript 是一种动态、弱类型的脚本语言，主要用于增强网页的交互性。它可以在浏览器中运行，也可以在服务器端使用（如 Node.js）。JavaScript 代码通常嵌入在 HTML 文档中，通过 \u0026lt;script\u0026gt; 标签引入。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JavaScript Example\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello, JavaScript!\u0026lt;/h1\u0026gt; \u0026lt;script\u0026gt; console.log(\u0026#34;Hello, World!\u0026#34;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 2. JavaScript 基本语法 变量声明 JavaScript 使用 var、let 和 const 关键字来声明变量。\n1 2 3 let name = \u0026#34;Alice\u0026#34;; // 使用 let 声明变量 const age = 25; // 使用 const 声明常量 var isStudent = true; // 使用 var 声明变量（不推荐） var 关键字声明的变量具有函数作用域，而 let 和 const 具有块级作用域。推荐使用 let 和 const 来避免变量提升和作用域问题。\n数据类型 JavaScript 支持多种数据类型，包括：\n原始类型：String（字符串）、Number（数字）、Boolean（布尔值）、Null（空值）、Undefined（未定义）、Symbol（符号） 复杂类型：Object（对象）、Array（数组）、Function（函数） 1 2 3 4 5 let message = \u0026#34;Hello\u0026#34;; // String let count = 10; // Number let isActive = true; // Boolean let person = { name: \u0026#34;Bob\u0026#34;, age: 30 }; // Object let numbers = [1, 2, 3, 4, 5]; // Array 函数定义 函数是 JavaScript 的核心组成部分，可以通过多种方式定义。\n1 2 3 4 5 6 7 8 9 10 // 函数声明 function greet(name) { return \u0026#34;Hello, \u0026#34; + name + \u0026#34;!\u0026#34;; } // 函数表达式 const add = function(a, b) { return a + b; }; // 箭头函数 const multiply = (a, b) =\u0026gt; a * b; 箭头函数是 ES6 引入的一种简洁的函数定义方式，适用于简短的函数。\n条件语句 1 2 3 4 5 if (age \u0026gt;= 18) { console.log(\u0026#34;Adult\u0026#34;); } else { console.log(\u0026#34;Minor\u0026#34;); } 循环语句 1 2 console.log(i); } 事件处理 1 2 3 document.getElementById(\u0026#34;myButton\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, function() { alert(\u0026#34;Button clicked!\u0026#34;); }); 其中document是DOM（文档对象模型）的入口，getElementById方法用于获取指定ID的HTML元素，addEventListener方法用于为元素添加事件监听器。alert函数用于显示弹窗。\nJavaScript 语法糖 ES6 引入了许多语法糖，使代码更简洁易读。语法糖是指一些语法特性，它们并不增加语言的功能，但可以让代码更易于编写和理解。例如：\n1 2 3 4 5 6 7 // 传统函数定义 var add = function(a, b) { return a + b; }; // 箭头函数 const add = (a, b) =\u0026gt; a + b; 还有模板字符串、解构赋值、默认参数等：\n1 2 3 4 5 6 7 8 9 // 模板字符串 let name = \u0026#34;Alice\u0026#34;; let greeting = `Hello, ${name}!`; // 解构赋值 let [x, y] = [1, 2]; // 默认参数 function multiply(a, b = 1) { return a * b; } 3. JavaScript 应用场景 JavaScript 广泛应用于以下场景：\n前端开发：实现网页的动态效果和交互功能。 后端开发：使用 Node.js 构建服务器端应用。 移动应用开发：使用 React Native、Ionic 等框架开发跨平台移动应用。 桌面应用开发：使用 Electron 构建跨平台桌面应用。 游戏开发：使用 Phaser、Three.js 等库开发网页游戏。 物联网（IoT）：使用 JavaScript 控制硬件设备。 数据可视化：使用 D3.js、Chart.js 等库进行数据可视化展示。 4. 总结 JavaScript 是一种功能强大且灵活的编程语言，广泛应用于各种开发场景。通过掌握其基本概念和语法，初学者可以快速上手并开始构建自己的网页和应用程序。继续深入学习 JavaScript 的高级特性和框架，将有助于提升开发技能和项目质量。在现代前端开发中，许多框架和库（如 React、Vue、Angular）都依赖于 JavaScript，因此掌握这门语言对于前端开发者来说尤为重要。而JavaScript的超集TypeScript也越来越受各大公司青睐，学习JavaScript的同时也可以了解一下TypeScript。\n5. 参考资料 MDN Web Docs - JavaScript JavaScript.info W3Schools - JavaScript Tutorial ","date":"2025-10-11T21:37:37+08:00","permalink":"https://adam-code-line.github.io/p/javascript/","title":"JavaScript 基础知识入门"},{"content":"JavaScript中的常用函数(二) 前言 本文是JavaScript中的常用函数(一)的续篇，继续介绍一些JavaScript中常用的函数。\n字符串处理函数 trim() trim()函数用于去除字符串两端的空白字符（包括空格、制表符、换行符等）。它返回一个新的字符串，不会修改原字符串。\n1 2 3 let str = \u0026#34; Hello, World! \u0026#34;; let trimmedStr = str.trim(); console.log(trimmedStr); // 输出: \u0026#34;Hello, World!\u0026#34; toUpperCase() 和 toLowerCase() toUpperCase()函数将字符串转换为大写字母，而toLowerCase()函数将字符串转换为小写字母。\n1 2 3 let str = \u0026#34;Hello, World!\u0026#34;; console.log(str.toUpperCase()); // 输出: \u0026#34;HELLO, WORLD!\u0026#34; console.log(str.toLowerCase()); // 输出: \u0026#34;hello, world!\u0026#34; substring() substring(start, end)函数用于提取字符串中从start索引到end索引之间的子字符串。end参数是可选的，如果省略，则提取到字符串的末尾。substring()不会修改原字符串，而是返回一个新的字符串。\n1 2 3 let str = \u0026#34;Hello, World!\u0026#34;; let subStr = str.substring(0, 5); console.log(subStr); // 输出: \u0026#34;Hello\u0026#34; 与slice()不同，substring()返回的字符串包含start索引的字符，但不包含end索引的字符。如果start大于end，则会交换这两个参数。\n数组处理函数 push() 和 pop() push(element1, ..., elementN)函数用于向数组的末尾添加一个或多个元素，并返回新数组的长度。pop()函数用于从数组的末尾移除最后一个元素，并返回该元素。\n1 2 3 4 let arr = [1, 2, 3]; arr.push(4); // arr 变为 [1, 2, 3, 4] let lastElement = arr.pop(); // lastElement 为 4，arr 变为 [1, 2, 3] console.log(lastElement); // 输出: 4 shift() 和 unshift() shift()函数用于从数组的开头移除第一个元素，并返回该元素。unshift(element1, ..., elementN)函数用于向数组的开头添加一个或多个元素，并返回新数组的长度。\n1 2 3 4 let arr = [1, 2, 3]; let firstElement = arr.shift(); // firstElement 为 1，arr 变为 [2, 3] arr.unshift(0); // arr 变为 [0, 2, 3] console.log(firstElement); // 输出: 1 slice() slice(start, end)函数用于提取数组中从start索引到end索引之间的元素，返回一个新数组。end参数是可选的，如果省略，则提取到数组的末尾。\n1 2 3 let arr = [1, 2, 3, 4, 5]; let newArr = arr.slice(1, 4); console.log(newArr); // 输出: [2, 3, 4] 需要注意的是，slice()不会修改原数组，而是返回一个新的数组。start和end参数可以为负数，表示从数组末尾开始计算索引。start索引不会包含在返回的数组中，而end索引会包含在返回的数组中。\nsplice() splice(start, deleteCount, item1, item2, ...)函数用于在数组中添加或删除元素。它从start索引开始，删除deleteCount个元素，并可以插入一个或多个新元素。它返回一个包含被删除元素的新数组。\n1 2 3 let arr = [1, 2, 3, 4, 5]; let removedElements = arr.splice(1, 2, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;); // arr 变为 [1, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, 4, 5] console.log(removedElements); // 输出: [2, 3] indexOf() 和 lastIndexOf() indexOf(element, fromIndex)函数用于查找数组中指定元素的第一个索引位置，fromIndex参数是可选的，表示从该索引开始查找。lastIndexOf(element, fromIndex)函数用于查找数组中指定元素的最后一个索引位置。\n1 2 3 let arr = [1, 2, 3, 2, 1]; console.log(arr.indexOf(2)); // 输出: 1 console.log(arr.lastIndexOf(2)); // 输出: 3 forEach() forEach(callback(currentValue, index, array))函数用于对数组的每个元素执行指定的回调函数。它不会返回新数组，而是直接在原数组上进行操作。\n1 2 3 4 let arr = [1, 2, 3]; arr.forEach(function(element, index) { console.log(`索引 ${index} 的元素是 ${element}`); }); 这里的代码会输出数组中每个元素及其索引。\nmap() map(callback(currentValue, index, array))函数用于对数组的每个元素执行指定的回调函数，并返回一个新数组，包含回调函数的返回值。\n1 2 3 4 5 let arr = [1, 2, 3]; let mappedArr = arr.map(function(element) { return element * 2; }); console.log(mappedArr); // 输出: [2, 4, 6] 这里的代码会输出一个新数组，其中每个元素都是原数组元素的两倍。\nfilter() filter(callback(currentValue, index, array))函数用于对数组的每个元素执行指定的回调函数，并返回一个新数组，包含所有使回调函数返回true的元素。即返回符合条件的元素组成的新数组。\n1 2 3 4 5 let arr = [1, 2, 3, 4, 5]; let filteredArr = arr.filter(function(element) { return element % 2 === 0; }); console.log(filteredArr); // 输出: [2, 4] 这里的代码会输出一个新数组，包含所有偶数元素。\nreduce() reduce(callback(accumulator, currentValue, index, array), initialValue)函数用于对数组的每个元素执行指定的回调函数，将其结果汇总为单个值。accumulator是累加器，currentValue是当前元素，initialValue是可选的初始值。\n1 2 3 4 5 let arr = [1, 2, 3, 4]; let sum = arr.reduce(function(accumulator, currentValue) { return accumulator + currentValue; }, 0); console.log(sum); // 输出: 10 这里的代码会输出数组元素的总和。注意，reduce()不会修改原数组，而是读取数组的值并将结果存储在累加器中。\n结语 本文介绍了JavaScript中一些常用的字符串和数组处理函数，这些函数在日常开发中非常实用。掌握它们可以帮助我们更高效地处理数据和实现各种功能。希望本文对你有所帮助。\n","date":"2025-10-11T21:37:37+08:00","permalink":"https://adam-code-line.github.io/p/javascript/","title":"JavaScript中的常用函数(二)"},{"content":"JavaScript中的常用函数(一) 前言 JavaScript是一种广泛用于网页开发的脚本语言。本文将介绍一些JavaScript中常用的函数，帮助初学者更好地理解和使用这些函数。\n基本输入输出函数 alert() alert()函数用于在浏览器中显示一个警告对话框，通常用于向用户显示信息。\n1 alert(\u0026#34;Hello, World!\u0026#34;); 这里的代码会弹出一个对话框，显示“Hello, World!”消息。\nconsole.log() console.log()函数用于在浏览器的控制台中输出信息，通常用于调试代码。\n1 console.log(\u0026#34;This is a log message.\u0026#34;); 这里的代码会在控制台中输出“This is a log message.”。使用F12可以打开浏览器的开发者工具，查看控制台输出。\nprompt() prompt()函数用于显示一个对话框，提示用户输入信息，并返回用户输入的值。\n1 2 let name = prompt(\u0026#34;Please enter your name:\u0026#34;); console.log(\u0026#34;Hello, \u0026#34; + name + \u0026#34;!\u0026#34;); 这里的代码会弹出一个对话框，提示用户输入姓名，并在控制台中输出问候信息。\n数学函数 JavaScript提供了一些内置的数学函数，可以用于执行各种数学运算。\nMath.abs() Math.abs()函数用于返回一个数的绝对值。\n1 2 3 let num = -5; let absValue = Math.abs(num); console.log(absValue); // 输出: 5 这里的代码会输出5，即-5的绝对值。\nMath.round() Math.round()函数用于将一个数四舍五入到最接近的整数。\n1 2 3 let num = 4.7; let roundedValue = Math.round(num); console.log(roundedValue); // 输出: 5 这里的代码会输出5，即4.7四舍五入后的值。\n当输入的数为负数时：\n1 2 3 let num = -4.3; let roundedValue = Math.round(num); console.log(roundedValue); // 输出: -4 这里的代码会输出-4，即-4.3四舍五入后的值。\nMath.random() Math.random()函数用于返回一个0到1之间的随机数（包括0但不包括1）。\n1 2 let randomValue = Math.random(); console.log(randomValue); // 输出: 0到1之间的随机数 这里的代码会输出一个0到1之间的随机数。\n类型判断函数 typeof typeof运算符用于返回一个变量或表达式的数据类型。\n1 2 let value = 42; console.log(typeof value); // 输出: \u0026#34;number\u0026#34; 这里的代码会输出\u0026quot;number\u0026quot;，表示变量value的数据类型是数字。但typeof在判数组、对象和null时有些特殊：\n1 2 3 4 5 6 let arr = [1, 2, 3]; console.log(typeof arr); // 输出: \u0026#34;object\u0026#34; let obj = {name: \u0026#34;Alice\u0026#34;}; console.log(typeof obj); // 输出: \u0026#34;object\u0026#34; let n = null; console.log(typeof n); // 输出: \u0026#34;object\u0026#34; 可以看到数据、对象和null都会被判断为\u0026quot;object\u0026quot;类型。\ninstanceof instanceof运算符用于判断一个对象是否是某个类的实例。\n1 2 let date = new Date(); console.log(date instanceof Date); // 输出: true instanceof判断的原理是判断对象的原型链上是否存在该类的prototype属性。但对于基本数据类型（如字符串、数字等）使用instanceof会返回false：\n1 2 3 4 5 6 let str = \u0026#34;Hello\u0026#34;; console.log(str instanceof String); // 输出: false let num = 42; console.log(num instanceof Number); // 输出: false let bool = true; console.log(bool instanceof Boolean); // 输出: false 这里的代码会输出false，因为基本数据类型不是对应包装类的实例。\nconstructor constructor属性用于返回一个对象的构造函数。\n1 2 let arr = [1, 2, 3]; console.log(arr.constructor === Array); // 输出: true constructor有两个作用；\n可以用来判断对象的类型； 可以用来创建对象的实例。 对象实例可以通过constructor属性访问其构造函数：\n1 2 let obj = {}; console.log(obj.constructor === Object); // 输出: true 但是如果创建一个对象然后改变其原型，constructor就不能用来判断数据类型了：\n1 2 3 4 5 6 7 8 9 10 function Person(name) { this.name = name; } let person = new Person(\u0026#34;Alice\u0026#34;); console.log(person.constructor === Person); // 输出: true // 改变原型 person.__proto__ = {}; console.log(person.constructor === Person); // 输出: false Object.prototype.toString.call() Object.prototype.toString.call()方法用于返回一个对象的类型字符串。\n1 2 let arr = [1, 2, 3]; console.log(Object.prototype.toString.call(arr)); // 输出: \u0026#34;[object Array]\u0026#34; 这里的代码会输出\u0026quot;[object Array]\u0026quot;，表示变量arr是一个数组类型。对于其他数据类型也适用：\n1 2 3 4 5 6 7 8 9 10 let str = \u0026#34;Hello\u0026#34;; console.log(Object.prototype.toString.call(str)); // 输出: \u0026#34;[object String]\u0026#34; let num = 42; console.log(Object.prototype.toString.call(num)); // 输出: \u0026#34;[object Number]\u0026#34; let bool = true; console.log(Object.prototype.toString.call(bool)); // 输出: \u0026#34;[object Boolean]\u0026#34; let n = null; console.log(Object.prototype.toString.call(n)); // 输出: \u0026#34;[object Null]\u0026#34; let undefined; console.log(Object.prototype.toString.call(undefined)); // 输出: \u0026#34;[object Undefined]\u0026#34; 数据类型转换函数 JavaScript提供了一些函数用于将数据从一种类型转换为另一种类型。\nparseInt() parseInt()函数用于将字符串转换为整数。\n1 2 3 let str = \u0026#34;42\u0026#34;; let intValue = parseInt(str); console.log(intValue); // 输出: 42 这里的代码会输出42，即字符串\u0026quot;42\u0026quot;转换为整数后的值。\nparseFloat() parseFloat()函数用于将字符串转换为浮点数。\n1 2 3 let str = \u0026#34;3.14\u0026#34;; let floatValue = parseFloat(str); console.log(floatValue); // 输出: 3.14 这里的代码会输出3.14，即字符串\u0026quot;3.14\u0026quot;转换为浮点数后的值。\nString() String()函数用于将其他数据类型转换为字符串。\n1 2 3 let num = 100; let strValue = String(num); console.log(strValue); // 输出: \u0026#34;100\u0026#34; 这里的代码会输出字符串\u0026quot;100\u0026quot;，即数字100转换为字符串后的值。\n结语 本文介绍了一些常用的简单函数，包括输入输出函数、数学函数和数据类型转换函数。后面会介绍一些更复杂和实用的JavaScript函数。\n","date":"2025-10-11T21:37:37+08:00","permalink":"https://adam-code-line.github.io/p/javascript/","title":"JavaScript中的常用函数(一)"},{"content":"CSS 基础知识入门 前言 CSS（层叠样式表）全称Cascading Style Sheets，是用于描述 HTML 文档外观和格式的语言。本文将介绍 CSS 的基本概念、选择器及其应用，帮助初学者快速入门。\n1. CSS 基本概念 CSS 用于控制网页的布局、颜色、字体等视觉效果。它可以与 HTML 结合使用，通过选择器选择 HTML 元素并应用样式规则。 一个简单的 CSS 规则如下：\n1 2 3 4 selector { property: value; } selector：选择器，指定要应用样式的 HTML 元素。 property：属性，指定要设置的样式属性，如颜色、字体大小等。 value：值，指定属性的具体值。 2. 常用 CSS 选择器 通配选择器 通配选择器使用 * 符号，选择所有元素。\n1 2 3 4 * { margin: 0; padding: 0; } 元素选择器 元素选择器直接使用 HTML 标签名来选择元素。\n1 2 3 4 5 p { color: blue; font-size: 16px; } 类选择器 类选择器使用 . 符号，选择具有特定类名的元素。\n1 2 3 4 5 6 7 .button { background-color: green; color: white; padding: 10px 20px; border-radius: 5px; } ID 选择器 ID 选择器使用 # 符号，选择具有特定 ID 的元素。\n1 2 3 4 5 6 #header { background-color: lightgray; text-align: center; padding: 20px; } 组合选择器 组合选择器可以同时使用多种选择器来选择元素。\n1 2 3 4 5 div.container p { margin: 10px 0; line-height: 1.5; } 3. CSS 应用方式 CSS 可以通过三种方式应用到 HTML 文档中：\n内联样式 内联样式直接在 HTML 元素的 style 属性中定义样式。\n1 \u0026lt;p style=\u0026#34;color: red; font-size: 14px;\u0026#34;\u0026gt;This is a red paragraph.\u0026lt;/p\u0026gt; 内部样式表 内部样式表在 HTML 文档的 \u0026lt;head\u0026gt; 部分使用 \u0026lt;style\u0026gt; 标签定义样式。\n1 2 3 4 5 6 7 8 \u0026lt;head\u0026gt; \u0026lt;style\u0026gt; body { font-family: Arial, sans-serif; background-color: #f0f0f0; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; 外部样式表 外部样式表将 CSS 代码放在单独的 .css 文件中，并通过 \u0026lt;link\u0026gt; 标签引入。\n1 2 3 \u0026lt;head\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;styles.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; 其中rel属性指定链接类型，href属性指定CSS文件路径。\n4. 常用 CSS 属性 颜色属性 1 2 color: blue; /* 文字颜色 */ background-color: yellow; /* 背景颜色 */ 字体属性 1 2 3 font-size: 16px; /* 字体大小 */ font-family: \u0026#39;Arial\u0026#39;, sans-serif; /* 字体类型 */ font-weight: bold; /* 字体粗细 */ 布局属性 1 2 3 4 5 margin: 10px; /* 外边距 */ padding: 15px; /* 内边距 */ border: 1px solid black; /* 边框 */ width: 100%; /* 宽度 */ height: 200px; /* 高度 */ 5. 总结 css 是网页设计中不可或缺的技术，掌握其基本概念和常用选择器对于前端开发十分有帮助。现代的前端开发中，还会使用css预处理器（如Sass、Less）和框架（如Bootstrap、Tailwind CSS）来提高开发效率。能够熟练运用css，将大大提升网页的视觉效果和用户体验。\n6. 参考资料 MDN Web Docs - CSS ","date":"2025-10-11T21:28:45+08:00","permalink":"https://adam-code-line.github.io/p/css/","title":"CSS 基础知识入门"},{"content":"HTML 基础知识入门 前言 HTML（超文本标记语言）是构建网页的基础语言。本文将介绍 HTML 的基本概念、常用标签及其结构，帮助初学者快速入门。\n1. HTML 基本结构 一个标准的 HTML 文档包含以下基本结构：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is a simple HTML document.\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;!DOCTYPE html\u0026gt;：声明文档类型，告诉浏览器使用 HTML5 标准。 \u0026lt;html\u0026gt;：根元素，包含整个 HTML 文档。 \u0026lt;head\u0026gt;：包含文档的元数据，如字符集、标题和样式表。 \u0026lt;body\u0026gt;：包含网页的内容，如文本、图片和链接。 2. 常用 HTML 标签 标题标签 HTML 提供了六个级别的标题标签，分别是 \u0026lt;h1\u0026gt; 到 \u0026lt;h6\u0026gt;，其中 \u0026lt;h1\u0026gt; 是最高级别的标题。\n1 2 3 \u0026lt;h1\u0026gt;Main Title\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;Sub Title\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;Section Title\u0026lt;/h3\u0026gt; 段落标签 段落使用 \u0026lt;p\u0026gt; 标签表示。\n1 2 \u0026lt;p\u0026gt;This is a paragraph.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;This is another paragraph.\u0026lt;/p\u0026gt; 链接标签 链接使用 \u0026lt;a\u0026gt; 标签，href 属性指定链接地址。\n1 \u0026lt;a href=\u0026#34;https://www.example.com\u0026#34;\u0026gt;Visit Example.com\u0026lt;/a\u0026gt; 图片标签 图片使用 \u0026lt;img\u0026gt; 标签，src 属性指定图片路径，alt 属性提供替代文本。\n1 \u0026lt;img src=\u0026#34;image.jpg\u0026#34; alt=\u0026#34;Description of image\u0026#34;\u0026gt; 列表标签 HTML 支持有序列表和无序列表。\n有序列表使用 \u0026lt;ol\u0026gt; 标签，列表项使用 \u0026lt;li\u0026gt; 标签。 1 2 3 4 \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;First item\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Second item\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; 无序列表使用 \u0026lt;ul\u0026gt; 标签。 1 2 3 4 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;First item\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Second item\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 表格标签 表格使用 \u0026lt;table\u0026gt; 标签，表头使用 \u0026lt;th\u0026gt;，表行使用 \u0026lt;tr\u0026gt;，表格数据使用 \u0026lt;td\u0026gt;。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;Name\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Age\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Alice\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;30\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Bob\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;25\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; 3. HTML 属性 HTML 标签可以包含属性，用于提供额外的信息或配置。例如：\n1 2 \u0026lt;a href=\u0026#34;https://www.example.com\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;Open in new tab\u0026lt;/a\u0026gt; \u0026lt;img src=\u0026#34;image.jpg\u0026#34; alt=\u0026#34;Description\u0026#34; width=\u0026#34;600\u0026#34; height=\u0026#34;400\u0026#34;\u0026gt; href：指定链接地址。 target：指定链接打开方式，如 _blank 表示在新标签页打开。 width 和 height：指定图片的宽度和高度。 alt：提供图片的替代文本。 4. HTML 注释 HTML 注释使用 \u0026lt;!-- --\u0026gt; 包围，浏览器不会渲染注释内容。\n1 2 \u0026lt;!-- This is a comment --\u0026gt; \u0026lt;p\u0026gt;This is visible content.\u0026lt;/p\u0026gt; 5. 总结 本文介绍了 HTML 的基本结构、常用标签及其属性。掌握这些基础知识后，您可以开始创建简单的网页，并逐步深入学习更高级的 HTML 和前端技术。继续探索 HTML5 新特性，如多媒体标签（\u0026lt;video\u0026gt;、\u0026lt;audio\u0026gt;）和表单标签（\u0026lt;form\u0026gt;、\u0026lt;input\u0026gt;），将帮助您构建更丰富的网页内容。\n6. 参考资料 MDN Web Docs - HTML W3Schools - HTML Tutorial ","date":"2025-10-11T16:52:09+08:00","permalink":"https://adam-code-line.github.io/p/html/","title":"HTML 基础知识入门"},{"content":"Vue v-for 指令详解 前言 v-for 是 Vue.js 中用于渲染列表的指令，允许你基于一个数组或对象动态生成多个元素。本文将详细介绍 v-for 的用法、语法以及一些常见的实践。\n1. 基本语法 v-for 的基本语法如下：\n1 2 3 4 5 6 7 \u0026lt;template\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;item in items\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt; {{ item.name }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/template\u0026gt; 在这个例子中，items 是一个数组，item 是数组中的每个元素。v-for 会遍历 items 数组，并为每个元素生成一个 \u0026lt;li\u0026gt; 元素。 而 :key 是一个特殊属性，用于帮助 Vue 跟踪每个节点的身份，从而提高渲染效率。\n分隔符：v-for 的分隔符是 in，用于指定要遍历的数组或对象,但也可以使用 of 来替代 in。 2. 作用域 v-for 创建了一个新的作用域，在这个作用域内你可以访问当前迭代的元素以及它的索引：\n1 2 3 4 5 6 7 8 \u0026lt;template\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(item, index) in items\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt; \u0026lt;!-- 此处可以访问外层的变量，但`item`和`index`只能在该作用域内使用 --\u0026gt; {{ index }} - {{ item.name }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/template\u0026gt; 3. 遍历对象 除了遍历数组，v-for 也可以用来遍历对象的属性：\n1 2 3 4 5 6 7 \u0026lt;template\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(value, key) in object\u0026#34; :key=\u0026#34;key\u0026#34;\u0026gt; {{ key }}: {{ value }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/template\u0026gt; 在这个例子中，object 是一个对象，key 是对象的属性名，value 是对应的属性值。\n4. 获取索引 你还可以在 v-for 中获取当前元素的索引：\n1 2 3 4 5 6 7 \u0026lt;template\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(item, index) in items\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt; {{ index }} - {{ item.name }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/template\u0026gt; 这里，index 是当前元素在数组中的索引。\n5. 使用 v-for 渲染组件 v-for 也可以用来渲染自定义组件：\n1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;my-component v-for=\u0026#34;item in items\u0026#34; :key=\u0026#34;item.id\u0026#34; :data=\u0026#34;item\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 在这个例子中，my-component 是一个自定义组件，data 是传递给组件的属性。\n6. 注意事项 唯一的 key：确保每个元素都有一个唯一的 key，这对于 Vue 的虚拟 DOM 进行高效更新非常重要。 避免使用索引作为 key：除非列表是静态的或不会被重新排序，否则不建议使用索引作为 key，因为这可能会导致渲染问题。 性能考虑：对于大型列表，考虑使用虚拟滚动或分页来提高性能。 嵌套 v-for：可以在一个元素内嵌套多个 v-for，但要注意性能和可读性。 1 2 3 4 5 6 7 8 9 10 \u0026lt;template\u0026gt; \u0026lt;div v-for=\u0026#34;(group, groupIndex) in groups\u0026#34; :key=\u0026#34;group.id\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;{{ group.name }}\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(item, itemIndex) in group.items\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt; {{ item.name }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 7. 结合其他指令使用 当位于于同一元素上时，v-for 的优先级低于 v-if。这意味着 v-if 会先于 v-for 被处理，此时 v-if 的条件将无法访问到 v-for 作用域内定义的变量别名。\n1 2 3 4 5 6 7 8 \u0026lt;!--这会抛出错误，因为属性 it 在 v-if 中没有定义--\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p v-for=\u0026#34;it in items\u0026#34; v-if=\u0026#34;it.isActive\u0026#34; :key=\u0026#34;it.id\u0026#34;\u0026gt; {{ it.name }} \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 可以在外层包裹一个 \u0026lt;template\u0026gt; 标签来解决这个问题：\n1 2 3 4 5 6 7 8 9 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;template v-for=\u0026#34;item in items\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt; \u0026lt;p v-if=\u0026#34;item.isActive\u0026#34;\u0026gt; {{ item.name }} \u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 8. 总结 v-for 是 Vue.js 中非常强大且常用的指令，能够帮助开发者高效地渲染列表和处理动态数据。通过理解其语法、作用域以及与其他指令的结合使用，可以更好地利用 v-for 来构建复杂的用户界面。希望本文能帮助你更深入地理解和应用 v-for 指令。\n9. 参考资料 Vue.js 官方文档 - 列表渲染 ","date":"2025-10-11T16:03:55+08:00","permalink":"https://adam-code-line.github.io/p/vue-v-for-guide/","title":"Vue v-for 指令详解"},{"content":"Vue 条件渲染：v-if vs v-show 前言 在 Vue.js 中，条件渲染是构建动态用户界面的重要技术。Vue 提供了两种主要的条件渲染指令：v-if 和 v-show。本文将探讨这两者的区别、使用场景及其底层原理，帮助开发者更好地选择合适的指令来优化应用性能和用户体验。\n1. v-if 的工作原理与使用 v-if 指令用于根据条件动态地添加或移除 DOM 元素。当条件为真时，Vue 会创建并插入元素；当条件为假时，Vue 会销毁并移除元素。\n使用示例 1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p v-if=\u0026#34;isVisible\u0026#34;\u0026gt;这是一个可见的段落。\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; v-if 与 v-else 和 v-else-if v-if 可以与 v-else 和 v-else-if 结合使用，以实现多条件渲染。\n1 2 3 4 5 6 7 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p v-if=\u0026#34;status === \u0026#39;success\u0026#39;\u0026#34;\u0026gt;操作成功！\u0026lt;/p\u0026gt; \u0026lt;p v-else-if=\u0026#34;status === \u0026#39;error\u0026#39;\u0026#34;\u0026gt;操作失败！\u0026lt;/p\u0026gt; \u0026lt;p v-else\u0026gt;操作进行中...\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; v-if 控制多元素的渲染 v-if 也可以用于控制多个元素的渲染，通过包裹在一个父元素中实现。\n1 2 3 4 5 6 \u0026lt;template\u0026gt; \u0026lt;div v-if=\u0026#34;isVisible\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;标题\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;这是一个段落。\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 或者在 Vue 3 中使用 \u0026lt;template\u0026gt; 标签：\n1 2 3 4 \u0026lt;template v-if=\u0026#34;isVisible\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;标题\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;这是一个段落。\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; 2. v-show 的工作原理与使用 v-show 指令也用于条件渲染，但其工作原理与 v-if 不同。v-show 通过设置元素的 CSS display 属性来控制元素的显示与隐藏。当条件为真时，元素会被渲染并显示；当条件为假时，元素仍然存在于 DOM 中，但会被隐藏。\n使用示例 1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p v-show=\u0026#34;isVisible\u0026#34;\u0026gt;这是一个可见的段落。\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 3. v-if vs v-show 的区别 特性 v-if v-show DOM 操作 动态添加和移除元素 仅切换 CSS display 属性 初始渲染性能 较慢，因为需要创建和销毁元素 较快，因为元素始终存在于 DOM 中 适用场景 条件不频繁变化的情况 条件频繁变化的情况 内存占用 较低，因为不需要保留元素 较高，因为元素始终存在于 DOM 中 事件监听 事件监听器会被移除 事件监听器始终存在 4. 选择指南 使用 v-if 当条件不频繁变化，且需要节省内存时。例如，用户登录状态的切换。 使用 v-show 当条件频繁变化，且需要快速切换显示状态时。例如，选项卡切换或模态框显示。 5. 执行顺序 在 Vue 的渲染过程中，当 v-if 和 v-show 同时存在于一个元素的时候，v-if 会优先执行。也就是说，如果 v-if 条件为假，元素不会被渲染，v-show 的条件将不会被评估。但 Vue 官方并不推荐同时使用这两个指令在同一个元素上，因为这可能会导致代码的可读性和维护性降低。\n6. 总结 在选择使用 v-if 还是 v-show 时，开发者需要根据具体的业务场景和性能需求来做出决策。一般来说，v-if 更适合用于条件不频繁变化的场景，而 v-show 则更适合用于需要频繁切换显示状态的场景。通过合理地使用这两种指令，可以有效地提升 Vue 应用的性能和用户体验。\n7. 参考资料 Vue.js 官方文档 - 条件渲染 ","date":"2025-10-11T11:07:50+08:00","permalink":"https://adam-code-line.github.io/p/v-if-v-show/","title":"Vue 条件渲染：v-if vs v-show"},{"content":"Vue 计算属性原理 前言 本文为想学习 Vue 计算属性的前端开发者准备，涵盖 computed 的工作原理及其在 Vue 3 中的实现机制。\n1. 为什么学习计算属性原理 Vue的计算属性能够描述依赖响应式状态复杂逻辑，并且计算属性值会基于其响应式依赖被缓存,只有在computed属性的响应式依赖发生变化时才会重新计算。这种特性使得计算属性在性能优化和代码简洁性方面具有显著优势。\n2. 计算属性的工作原理 计算属性通过 computed 函数创建，接受一个 getter 函数，并返回一个包含 .value 属性的响应式对象。其核心原理如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 function computed(getterOrOptions) { // getter 函数 let getter; // setter 函数 let setter; // 标准化参数 if (isFunction(getterOrOptions)) { // 表面传入的是 getter 函数，不能修改计算属性的值 getter = getterOrOptions; setter = process.env.NODE_ENV !== \u0026#34;production\u0026#34; ? () =\u0026gt; { console.warn(\u0026#34;Write operation failed: computed value is readonly\u0026#34;); } : NOOP; } else { getter = getterOrOptions.get; setter = getterOrOptions.set; } // 数据是否脏的 let dirty = true; // 计算结果 let value; let computed; // 创建副作用函数 const runner = effect(getter, { // 延时执行 lazy: true, // 标记这是一个 computed effect 用于在 trigger 阶段的优先级排序 computed: true, // 调度执行的实现 scheduler: () =\u0026gt; { if (!dirty) { dirty = true; // 派发通知，通知运行访问该计算属性的 activeEffect trigger(computed, \u0026#34;set\u0026#34; /* SET */, \u0026#34;value\u0026#34;); } }, }); // 创建 computed 对象 computed = { __v_isRef: true, // 暴露 effect 对象以便计算属性可以停止计算 effect: runner, get value() { // 计算属性的 getter if (dirty) { // 只有数据为脏的时候才会重新计算 value = runner(); dirty = false; } // 依赖收集，收集运行访问该计算属性的 activeEffect track(computed, \u0026#34;get\u0026#34; /* GET */, \u0026#34;value\u0026#34;); return value; }, set value(newValue) { // 计算属性的 setter setter(newValue); }, }; return computed; } 脏检查：计算属性通过 dirty 标志来判断是否需要重新计算值。当依赖的响应式数据发生变化时，调度器会将 dirty 设置为 true。 依赖收集：当访问计算属性的 .value 时，会调用 track 函数，将当前的副作用函数与该计算属性关联起来。 触发更新：当计算属性的依赖发生变化时，调度器会调用 trigger 函数，通知所有依赖该计算属性的副作用函数重新执行。 缓存机制：计算属性只有在其依赖发生变化时才会重新计算，这通过 dirty 标志实现，从而提高性能。 3. 可写计算属性 计算属性默认是只读的，当尝试修改一个计算属性时，会在开发环境下发出警告，但在某些情况下，我们也可以同时提供getter和setter来创建可写的计算属性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;script setup\u0026gt; import { ref, computed } from \u0026#39;vue\u0026#39; const firstName = ref(\u0026#39;Li\u0026#39;) const lastName = ref(\u0026#39;Hua\u0026#39;) const fullName = computed({ // getter get() { return firstName.value + \u0026#39; \u0026#39; + lastName.value }, // setter set(newValue) { //这里使用的是解构赋值语法 [firstName.value, lastName.value] = newValue.split(\u0026#39; \u0026#39;) } }) \u0026lt;/script\u0026gt; 4. 计算属性与普通方法的区别 计算属性与普通方法的主要区别在于缓存机制。普通方法每次调用都会执行函数体，而计算属性只有在其依赖发生变化时才会重新计算，这使得计算属性在性能上更优。\n计算属性更适合用于依赖响应式数据的复杂逻辑，而普通方法更适合用于不依赖响应式数据的简单逻辑。\n5. 计算属性的实际应用 计算属性在实际开发中有广泛的应用场景，例如：\n表单输入的实时验证：可以使用计算属性来根据输入的值动态计算验证结果，从而实现实时反馈。 复杂数据的展示：在展示复杂数据时，可以使用计算属性来处理数据的格式化和转换，简化模板逻辑。 依赖于多个数据源的计算：当一个值依赖于多个响应式数据时，可以使用计算属性来集中管理这些依赖关系，提高代码的可维护性。 1 2 3 const total = computed(() =\u0026gt; { return items.reduce((sum, item) =\u0026gt; sum + item.price * item.quantity, 0) }) 6. 总结 通过学习 Vue 计算属性的工作原理，开发者可以更好地理解其内部机制，从而在实际开发中更有效地利用这一特性。计算属性不仅提高了代码的简洁性和可读性，还通过缓存机制优化了性能，是 Vue 开发中不可或缺的工具。\n7. 参考资料 Vue.js 官方文档 - 计算属性 深入浅出 Vue 计算属性 computed 的使用与优化 计算属性：Vue3探秘系列— computed的实现原理（六） ","date":"2025-10-09T18:45:11+08:00","permalink":"https://adam-code-line.github.io/p/computed/","title":"Vue 计算属性原理 "},{"content":"Vue 响应式原理 前言 本文为想学习 Vue 响应式系统的前端开发者准备，涵盖 ref 和 reactive 的工作原理及其在 Vue 3 中的实现机制。\n为什么学习响应式原理 学习 Vue 的响应式原理可以帮助开发者更好地理解框架的内部机制，从而在实际开发中更有效地利用这些特性。掌握响应式原理有助于：\n提高调试能力：了解数据是如何变化的，可以更快地定位问题。 优化性能：通过合理使用响应式 API，减少不必要的渲染和计算。 增强代码可读性：清晰的理解数据流动，有助于编写更易于维护的代码。 Vue 响应式系统概述 Vue 3 的响应式系统基于 ES6 的 Proxy 对象实现，主要通过 ref 和 reactive 两个 API 来创建响应式数据。\nref：用于创建基本类型的响应式数据，如字符串、数字、布尔值等。它返回一个包含 .value 属性的对象。 reactive：用于创建复杂类型的响应式数据，如对象和数组。 这两个 API 都会追踪数据的变化，并在数据更新时通知相关的组件进行重新渲染。\nref 的工作原理 ref 函数接受一个初始值，并返回一个包含该值的响应式对象。其核心原理如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function ref(initialValue) { const r = { get value() { // 依赖收集 track(r, \u0026#39;value\u0026#39;) return initialValue }, set value(newValue) { initialValue = newValue // 触发更新 trigger(r, \u0026#39;value\u0026#39;) } } return r } 依赖收集：当访问 ref 的 .value 属性时，会调用 track 函数，将当前的副作用函数（如组件的渲染函数）与该属性关联起来。 触发更新：当修改 .value 属性时，会调用 trigger 函数，通知所有依赖该属性的副作用函数重新执行。 reactive 的工作原理 reactive 函数接受一个对象，并返回该对象的响应式代理。其核心原理如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function reactive(target) { return new Proxy(target, { get(target, key) { // 依赖收集 track(target, key) return Reflect.get(target, key) }, set(target, key, value) { const result = Reflect.set(target, key, value) // 触发更新 trigger(target, key) return result } }) } 依赖收集：当访问对象的属性时，会调用 track 函数，将当前的副作用函数与该属性关联起来。 触发更新：当修改对象的属性时，会调用 trigger 函数，通知所有依赖该属性的副作用函数重新执行。 依赖追踪与副作用函数 Vue 使用一个全局的 activeEffect 变量来追踪当前正在执行的副作用函数。当副作用函数执行时，activeEffect 会被设置为该函数。当访问响应式数据时，track 函数会将 activeEffect 与该数据关联起来。\n1 2 3 4 5 6 7 8 9 let activeEffect = null function effect(fn) { const effectFn = () =\u0026gt; { activeEffect = effectFn fn() activeEffect = null } effectFn() } effect 函数：接受一个函数作为参数，并将其包装为副作用函数。执行该函数时，会设置 activeEffect，从而实现依赖收集。 track 函数：将 activeEffect 与访问的属性关联起来，存储在一个依赖集合中。 trigger 函数：当属性值发生变化时，遍历依赖集合，执行所有关联的副作用函数。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 const targetMap = new WeakMap() function track(target, key) { if (!activeEffect) return let depsMap = targetMap.get(target) if (!depsMap) { depsMap = new Map() targetMap.set(target, depsMap) } let dep = depsMap.get(key) if (!dep) { dep = new Set() depsMap.set(key, dep) } dep.add(activeEffect) } function trigger(target, key) { const depsMap = targetMap.get(target) if (!depsMap) return const dep = depsMap.get(key) if (dep) { dep.forEach(effect =\u0026gt; effect()) } } targetMap：使用 WeakMap 存储每个响应式对象及其属性的依赖集合。 track 函数：将当前的 activeEffect 添加到对应属性的依赖集合中。 trigger 函数：遍历属性的依赖集合，执行所有副作用函数。 ref 与 reactive 的区别与联系 数据类型：ref 适用于基本类型数据，而 reactive 适用于对象和数组。 访问方式：ref 需要通过 .value 访问和修改值，而 reactive 可以直接通过属性访问和修改。 嵌套响应式：reactive 会递归地将嵌套对象转换为响应式，而 ref 只会对其初始值进行响应式处理。 性能：ref 在处理大量基本类型数据时，性能可能优于 reactive，因为后者需要处理更多的代理逻辑。 使用注意： reactive底层是通过Proxy实现的，因此不能直接对reactive对象进行解构赋值，否则会失去响应式特性，同样它也不能监听原始数据类型。相反，ref可以安全地解构，因为它返回的是一个包含.value属性的对象。 结语 通过学习 Vue 的响应式原理，开发者可以更深入地理解框架的工作机制，从而在实际开发中更有效地利用这些特性。掌握 ref 和 reactive 的实现原理，有助于提高调试能力、优化性能，并编写更易于维护的代码。\n参考资料 Vue 3 源码解析 Vue3响应式：ref vs reactive，5分钟消除使用困惑 ","date":"2025-10-09T17:00:49+08:00","permalink":"https://adam-code-line.github.io/p/ref-reactive/","title":"Vue 响应式原理 "},{"content":"TypeScript 学习指南 前言 本文为想系统学习 TypeScript 的前端开发者准备，覆盖从基础类型、配置、进阶类型到在 Vue 项目中使用 TypeScript 的简单实战示例。\n1. 为什么学 TypeScript 静态类型可以在编译期发现很多常见错误，提高代码可维护性。 与现代 IDE（例如 VS Code）结合，能获得更好的智能提示、重构支持和文档提示。 2. 快速开始 1 2 3 4 # 初始化项目 pnpm init -y pnpm add -D typescript npx tsc --init 这会生成 tsconfig.json。\n一个常见的 tsconfig.json 最小配置：\n1 2 3 4 5 6 7 8 9 10 11 12 { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;ES2020\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;ESNext\u0026#34;, \u0026#34;moduleResolution\u0026#34;: \u0026#34;Node\u0026#34;, \u0026#34;strict\u0026#34;: true, \u0026#34;jsx\u0026#34;: \u0026#34;preserve\u0026#34;, \u0026#34;esModuleInterop\u0026#34;: true, \u0026#34;skipLibCheck\u0026#34;: true, \u0026#34;forceConsistentCasingInFileNames\u0026#34;: true } } 3. 基础类型示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 原始类型 let s: string = \u0026#39;hello\u0026#39; let n: number = 123 let b: boolean = true // 数组与元组 let arr: number[] = [1,2,3] let tup: [string, number] = [\u0026#39;age\u0026#39;, 18] // 联合类型与类型别名 type ID = string | number let id: ID = \u0026#39;abc\u0026#39; // 接口与类型 interface User { id: ID; name: string } const user: User = { id: \u0026#39;u1\u0026#39;, name: \u0026#39;Alice\u0026#39; } // 函数类型 function add(a: number, b: number): number { return a + b } 4. 进阶类型 泛型（Generics） 映射类型（Mapped Types） 条件类型（Conditional Types） 泛型示例：\n1 2 function identity\u0026lt;T\u0026gt;(arg: T): T { return arg } const s = identity\u0026lt;string\u0026gt;(\u0026#39;hi\u0026#39;) 5. 在 Vue 中使用 TypeScript 推荐使用 script setup lang=\u0026quot;ts\u0026quot;。 在 Vite + Vue 项目中，shims-vue.d.ts 可能需要声明 Vue 文件支持： 1 2 3 4 5 declare module \u0026#39;*.vue\u0026#39; { import { DefineComponent } from \u0026#39;vue\u0026#39; const component: DefineComponent\u0026lt;{}, {}, any\u0026gt; export default component } 组件示例：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { defineProps } from \u0026#39;vue\u0026#39; interface Props { title: string } const props = defineProps\u0026lt;Props\u0026gt;() \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;h1\u0026gt;{{ props.title }}\u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; 6. 常见模式与技巧 使用 as const 固定字面量类型。 使用 unknown 代替 any 做更严格的类型收敛。 使用 ReturnType\u0026lt;\u0026gt;, Partial\u0026lt;\u0026gt;, Required\u0026lt;\u0026gt; 等工具类型提高复用性。 7. 配合工具链 ESLint 与 TypeScript: 使用 @typescript-eslint/parser 和 @typescript-eslint/eslint-plugin。 编辑器：确保安装 TypeScript 相关插件并在项目中使用本地 TypeScript（避免全局版本不一致）。 8. 练习任务 把一个小型 JS 项目迁移到 TypeScript（从 --strict 放宽到逐步开启 strict 规则）。 写一个简单的泛型工具函数并写测试（Vitest）。 9. 参考资源 TypeScript 官方文档 TypeScript Deep Dive Vue + TypeScript 官方指南 TypeScript ESLint ","date":"2025-10-01T11:35:10+08:00","image":"https://adam-code-line.github.io/p/typescript-learning-guide/cover_hu_eee5813ff9235310.jpg","permalink":"https://adam-code-line.github.io/p/typescript-learning-guide/","title":"TypeScript"},{"content":"Vue 学习概述 前言 Vue是款由尤雨溪（Evan You）创建的渐进式 JavaScript 框架，旨在通过简洁易用的 API 构建用户界面。Vue 采用组件化开发方式，支持响应式数据绑定和组合式 API，使得构建复杂应用变得高效且灵活。Vue 的核心特点包括响应式系统、组件化、虚拟 DOM 和单向数据流等。以下是对 Vue 的简要讲解：\n核心概念 响应式系统 Vue 的响应式系统允许数据变化时自动更新视图。通过使用 ref 和 reactive，开发者可以轻松创建响应式数据对象。当这些数据发生变化时，相关的组件会自动重新渲染。\n组件（Components） 组件是 Vue 应用的基本构建块。每个组件都是一个独立的、可复用的 UI 单元，可以包含自己的状态和逻辑。组件可以是单文件组件（.vue 文件），也可以是函数式组件。组件化使得代码更易维护和复用。\n模板语法（Template Syntax） Vue 使用基于 HTML 的模板语法，允许开发者声明式地绑定数据到 DOM 元素。模板中可以使用指令（如 v-if、v-for）来控制渲染逻辑。\n虚拟 DOM（Virtual DOM） Vue 使用虚拟 DOM 来提高性能。虚拟 DOM 是一个轻量级的 JavaScript 对象，表示真实 DOM 的副本。当组件的状态发生变化时，Vue 会首先更新虚拟 DOM，然后通过比较新旧虚拟 DOM 的差异，最小化地更新真实 DOM。\n单向数据流（One-way Data Flow） Vue 采用单向数据流的设计理念，数据从父组件传递到子组件。这样可以更容易地追踪数据的变化，提升应用的可维护性。\n组合式 API（Composition API） Vue 3 引入了组合式 API，允许开发者通过函数来组织组件逻辑。常用的组合式 API 包括 setup 函数、ref、reactive、computed 和 watch 等。\n开发环境与快速启动 推荐使用 最新版的 Node.js 与 Vite 创建项目：\n1 2 3 4 5 6 7 npm create vue@latest #使用 npm 创建项目,新手推荐使用 npm 该指令将会安装并执行 create-vue 脚本,它是 Vue 官方推荐的脚手架工具，你将会看到交互式的选项来配置你的项目，例如选择模板（如 Vue 3 + TypeScript）、添加路由、状态管理等，包括项目名称，这里假定项目名为 my-vue-app。 cd my-vue-app #进入项目目录 npm install #安装依赖 npm run dev\t#启动开发服务器 打开 http://localhost:5173 即可预览。\n组合式 API 基本示例 以下示例展示计数器的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count: {{ count }}\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { ref } from \u0026#39;vue\u0026#39; const count = ref(0) function increment() { count.value++ } \u0026lt;/script\u0026gt; 组件传参与事件 父组件向子组件传递 props，并通过 emit 触发事件：\nChild.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;onClick\u0026#34;\u0026gt;{{ label }}\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { defineProps, defineEmits } from \u0026#39;vue\u0026#39; const props = defineProps\u0026lt;{ label: string }\u0026gt;() const emit = defineEmits\u0026lt;{ (e: \u0026#39;clicked\u0026#39;): void }\u0026gt;() function onClick() { emit(\u0026#39;clicked\u0026#39;) } \u0026lt;/script\u0026gt; Parent.vue\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;template\u0026gt; \u0026lt;Child label=\u0026#34;Click me\u0026#34; @clicked=\u0026#34;handle\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import Child from \u0026#39;./Child.vue\u0026#39; function handle() { console.log(\u0026#39;child clicked\u0026#39;) } \u0026lt;/script\u0026gt; 路由（Vue Router）基础 安装并配置 Vue Router：\n1 pnpm add vue-router@4 src/router/index.ts 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 import { createRouter, createWebHistory } from \u0026#39;vue-router\u0026#39; import Home from \u0026#39;../views/Home.vue\u0026#39; import About from \u0026#39;../views/About.vue\u0026#39; const routes = [ { path: \u0026#39;/\u0026#39;, component: Home }, { path: \u0026#39;/about\u0026#39;, component: About }, ] export const router = createRouter({ history: createWebHistory(), routes, }) 在 main.ts 中挂载：\n1 2 3 4 5 import { createApp } from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import { router } from \u0026#39;./router\u0026#39; createApp(App).use(router).mount(\u0026#39;#app\u0026#39;) 状态管理（Pinia） 使用 Pinia 取代 Vuex：\n1 pnpm add pinia 示例 store：\n1 2 3 4 5 6 7 8 9 // stores/counter.ts import { defineStore } from \u0026#39;pinia\u0026#39; import { ref } from \u0026#39;vue\u0026#39; export const useCounter = defineStore(\u0026#39;counter\u0026#39;, () =\u0026gt; { const count = ref(0) function increment() { count.value++ } return { count, increment } }) 在主应用中挂载 Pinia：\n1 2 import { createPinia } from \u0026#39;pinia\u0026#39; createApp(App).use(createPinia()).use(router).mount(\u0026#39;#app\u0026#39;) 组件中使用：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { useCounter } from \u0026#39;@/stores/counter\u0026#39; const counter = useCounter() \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{{ counter.count }}\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026#34;counter.increment\u0026#34;\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 常用工具与测试 开发工具：Vite、ESLint、Prettier、TypeScript。 测试：Vitest + @vue/test-utils。 简单的 Vitest 测试示例：\n1 2 3 4 5 6 7 8 9 10 11 // tests/example.spec.ts import { describe, it, expect } from \u0026#39;vitest\u0026#39; import { mount } from \u0026#39;@vue/test-utils\u0026#39; import Hello from \u0026#39;../src/components/HelloWorld.vue\u0026#39; describe(\u0026#39;Hello\u0026#39;, () =\u0026gt; { it(\u0026#39;renders properly\u0026#39;, () =\u0026gt; { const wrapper = mount(Hello) expect(wrapper.text()).toContain(\u0026#39;Hello\u0026#39;) }) }) 部署与发布建议 小型项目可以使用 Vercel 或 Netlify 直接部署，无需复杂配置。 打包命令： 1 2 3 pnpm build # 本地预览 pnpm preview 参考资源 Vue 3 官方文档 Vue Router 文档 Pinia 文档 Vitest 文档 ","date":"2025-10-01T10:52:24+08:00","image":"https://adam-code-line.github.io/p/vue-learning-guide/cover_hu_1d9a212cbcfa3493.jpg","permalink":"https://adam-code-line.github.io/p/vue-learning-guide/","title":"Vue概述"},{"content":"前端学习路线 前言 写博客是把自己学到的知识沉淀并分享给别人的好方法。本文模仿项目中的风格，给出一套清晰的前端学习路线，适用于刚入门的同学，也适合想系统提升的开发者。\n为什么需要一条明确的学习路线 前端技术栈庞杂，工具和框架迭代快。如果没有系统性的学习计划，容易在碎片化的资料中迷失，不知下一步该学什么。一个合理的路线能帮助你建立知识体系、提升可迁移能力，并且尽早能做出完整的项目。\n学习路线总览 阶段 0：准备 (工具, 英语, 开发环境) 阶段 1：基础前端三剑客 (HTML/CSS/JavaScript) 阶段 2：前端三件套 (框架, 路由, 状态管理) 阶段 3：进阶 (TypeScript, 构建工具, 性能, 无障碍) 阶段 4：全栈与工程化 (后端基础, 部署, 测试) 阶段 5：项目驱动学习与实习面试准备 下面逐步展开每个阶段的推荐内容与练习方式。\n阶段 0：准备 安装并熟练使用一套编辑器 (VS Code 推荐) 和常用插件 (格式化, ESLint, vue(official)). 学习使用 Git 与 GitHub，掌握基本的 push、分支与 Pull Request 流程。 提升阅读英文文档的能力，前端优秀资源大多以英文为主。 阶段 1：基础 (约 1–2 个月) HTML: 语义化标签, 表单, 可访问性 (ARIA) 基础. CSS: 盒模型, Flexbox, Grid, 响应式设计, 常见布局技巧. JavaScript: 语法, 闭包, 原型链, 异步 (Promise, async/await), 模块化. 练习：实现若干静态页面（登录页、博客列表页、卡片布局），并尝试移动端适配。\n阶段 2：前端三件套 (约 1–3 个月) 框架: Vue 3 (或 React/Angular, 视团队与个人喜好). 掌握组件, 组合式 API (Vue 的 script setup), 生命周期, Props/Emit. 路由: 客户端路由的使用与懒加载 (例如 Vue Router). 状态管理: Pinia (Vue) 或 Redux (React) 的基本模式与实践. 练习：基于框架实现一个小型应用（Todo、简单博客、记账工具），包含路由和状态管理。\n阶段 3：进阶 (约 2–4 个月) TypeScript: 类型系统, 泛型, 声明文件 (.d.ts), 与现有 JS 项目迁移技巧. 构建工具: Vite / Webpack / Rollup 的基础配置与性能优化思路. CSS 工具: TailwindCSS, 预处理器 (Sass/LESS), CSS Modules. 性能与可访问性: 懒加载, code-splitting, 图片优化, 无障碍 (a11y) 最佳实践. 练习：给已有项目引入 TypeScript，做一次性能审计并逐项优化。\n阶段 4：全栈与工程化 (约 2–4 个月) 后端基础: RESTful API, GraphQL, 基础数据库 (Postgres, MongoDB) 概念. 部署: Docker, CI/CD (GitHub Actions), 托管平台 (Vercel, Netlify, 云主机). 测试: 单元测试 (Vitest/Jest), 端到端测试 (Cypress). 监控与日志: Sentry, 性能监控 (Lighthouse). 练习：把应用后端作为简单服务部署，使用 GitHub Actions 做自动化部署。\n阶段 5：项目驱动学习与面试准备 用项目驱动: 选择一个中等复杂度的项目 (支持用户登录, 数据持久化, 文件上传, 搜索/筛选), 把学习的技术整合进来. 写技术博客与读源码: 把你遇到的问题记录成文章, 帮助他人也帮助自己. 面试题训练: 算法基础, 网络/浏览器原理, 系统设计的简要理解. 学习建议 输出优先于输入: 能把学到的知识写成文章或实现成项目, 才算真正掌握. 定期复盘: 每 2–4 周总结学习进度, 调整计划. 社区与开源: 参与讨论, PR, 能快速提升工程能力. 参考资源（部分） MDN (HTML/CSS/JS) Vue 官方文档 / React 官方文档 Vite, Tailwind, TypeScript 官方指南 学习路线图 ⬇️ 下载 前端学习路线图(出处:https://front-talk.com/roadmap) ","date":"2025-09-30T11:04:33+08:00","image":"https://adam-code-line.github.io/p/frontend-learning-path/cover_hu_ffc67913452221a7.jpg","permalink":"https://adam-code-line.github.io/p/frontend-learning-path/","title":"前端学习路线"},{"content":"第一次写博客 在很早之前就有过写博客的想法，但是一直没有付诸行动。直到最近，终于决定开始记录自己的生活和学习经历。一开始本来是想着自己写一个博客系统，但是考虑到时间和精力的问题，最终选择了使用Hugo这个静态网站生成器。经过一番折腾，终于搭建好了自己的个人博客网站。希望自己以后能够坚持更新，分享更多有趣的内容和有用的知识。\n","date":"2025-09-21T23:35:33+08:00","image":"https://adam-code-line.github.io/p/life/cover_hu_dde4c1f358e5b772.jpg","permalink":"https://adam-code-line.github.io/p/life/","title":"我的第一篇文章"}]