[{"content":"HTML 基础知识入门 HTML（超文本标记语言）是构建网页的基础语言。本文将介绍 HTML 的基本概念、常用标签及其结构，帮助初学者快速入门。\n1. HTML 基本结构 一个标准的 HTML 文档包含以下基本结构：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is a simple HTML document.\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;!DOCTYPE html\u0026gt;：声明文档类型，告诉浏览器使用 HTML5 标准。 \u0026lt;html\u0026gt;：根元素，包含整个 HTML 文档。 \u0026lt;head\u0026gt;：包含文档的元数据，如字符集、标题和样式表。 \u0026lt;body\u0026gt;：包含网页的内容，如文本、图片和链接。 2. 常用 HTML 标签 标题标签 HTML 提供了六个级别的标题标签，分别是 \u0026lt;h1\u0026gt; 到 \u0026lt;h6\u0026gt;，其中 \u0026lt;h1\u0026gt; 是最高级别的标题。\n1 2 3 \u0026lt;h1\u0026gt;Main Title\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;Sub Title\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;Section Title\u0026lt;/h3\u0026gt; 段落标签 段落使用 \u0026lt;p\u0026gt; 标签表示。\n1 2 \u0026lt;p\u0026gt;This is a paragraph.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;This is another paragraph.\u0026lt;/p\u0026gt; 链接标签 链接使用 \u0026lt;a\u0026gt; 标签，href 属性指定链接地址。\n1 \u0026lt;a href=\u0026#34;https://www.example.com\u0026#34;\u0026gt;Visit Example.com\u0026lt;/a\u0026gt; 图片标签 图片使用 \u0026lt;img\u0026gt; 标签，src 属性指定图片路径，alt 属性提供替代文本。\n1 \u0026lt;img src=\u0026#34;image.jpg\u0026#34; alt=\u0026#34;Description of image\u0026#34;\u0026gt; 列表标签 HTML 支持有序列表和无序列表。\n有序列表使用 \u0026lt;ol\u0026gt; 标签，列表项使用 \u0026lt;li\u0026gt; 标签。 1 2 3 4 \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;First item\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Second item\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; 无序列表使用 \u0026lt;ul\u0026gt; 标签。 1 2 3 4 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;First item\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Second item\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 表格标签 表格使用 \u0026lt;table\u0026gt; 标签，表头使用 \u0026lt;th\u0026gt;，表行使用 \u0026lt;tr\u0026gt;，表格数据使用 \u0026lt;td\u0026gt;。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;Name\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Age\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Alice\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;30\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Bob\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;25\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; 3. HTML 属性 HTML 标签可以包含属性，用于提供额外的信息或配置。例如：\n1 2 \u0026lt;a href=\u0026#34;https://www.example.com\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;Open in new tab\u0026lt;/a\u0026gt; \u0026lt;img src=\u0026#34;image.jpg\u0026#34; alt=\u0026#34;Description\u0026#34; width=\u0026#34;600\u0026#34; height=\u0026#34;400\u0026#34;\u0026gt; href：指定链接地址。 target：指定链接打开方式，如 _blank 表示在新标签页打开。 width 和 height：指定图片的宽度和高度。 alt：提供图片的替代文本。 4. HTML 注释 HTML 注释使用 \u0026lt;!-- --\u0026gt; 包围，浏览器不会渲染注释内容。\n1 2 \u0026lt;!-- This is a comment --\u0026gt; \u0026lt;p\u0026gt;This is visible content.\u0026lt;/p\u0026gt; 5. 总结 本文介绍了 HTML 的基本结构、常用标签及其属性。掌握这些基础知识后，您可以开始创建简单的网页，并逐步深入学习更高级的 HTML 和前端技术。继续探索 HTML5 新特性，如多媒体标签（\u0026lt;video\u0026gt;、\u0026lt;audio\u0026gt;）和表单标签（\u0026lt;form\u0026gt;、\u0026lt;input\u0026gt;），将帮助您构建更丰富的网页内容。\n6. 参考资料 MDN Web Docs - HTML W3Schools - HTML Tutorial ","date":"2025-10-11T16:52:09+08:00","permalink":"https://adam-code-line.github.io/p/html/","title":"HTML 基础知识入门"},{"content":"Vue v-for 指令详解 v-for 是 Vue.js 中用于渲染列表的指令，允许你基于一个数组或对象动态生成多个元素。本文将详细介绍 v-for 的用法、语法以及一些常见的实践。\n1. 基本语法 v-for 的基本语法如下：\n1 2 3 4 5 6 7 \u0026lt;template\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;item in items\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt; {{ item.name }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/template\u0026gt; 在这个例子中，items 是一个数组，item 是数组中的每个元素。v-for 会遍历 items 数组，并为每个元素生成一个 \u0026lt;li\u0026gt; 元素。 而 :key 是一个特殊属性，用于帮助 Vue 跟踪每个节点的身份，从而提高渲染效率。\n分隔符：v-for 的分隔符是 in，用于指定要遍历的数组或对象,但也可以使用 of 来替代 in。 2. 作用域 v-for 创建了一个新的作用域，在这个作用域内你可以访问当前迭代的元素以及它的索引：\n1 2 3 4 5 6 7 8 \u0026lt;template\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(item, index) in items\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt; \u0026lt;!-- 此处可以访问外层的变量，但`item`和`index`只能在该作用域内使用 --\u0026gt; {{ index }} - {{ item.name }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/template\u0026gt; 3. 遍历对象 除了遍历数组，v-for 也可以用来遍历对象的属性：\n1 2 3 4 5 6 7 \u0026lt;template\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(value, key) in object\u0026#34; :key=\u0026#34;key\u0026#34;\u0026gt; {{ key }}: {{ value }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/template\u0026gt; 在这个例子中，object 是一个对象，key 是对象的属性名，value 是对应的属性值。\n4. 获取索引 你还可以在 v-for 中获取当前元素的索引：\n1 2 3 4 5 6 7 \u0026lt;template\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(item, index) in items\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt; {{ index }} - {{ item.name }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/template\u0026gt; 这里，index 是当前元素在数组中的索引。\n5. 使用 v-for 渲染组件 v-for 也可以用来渲染自定义组件：\n1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;my-component v-for=\u0026#34;item in items\u0026#34; :key=\u0026#34;item.id\u0026#34; :data=\u0026#34;item\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 在这个例子中，my-component 是一个自定义组件，data 是传递给组件的属性。\n6. 注意事项 唯一的 key：确保每个元素都有一个唯一的 key，这对于 Vue 的虚拟 DOM 进行高效更新非常重要。 避免使用索引作为 key：除非列表是静态的或不会被重新排序，否则不建议使用索引作为 key，因为这可能会导致渲染问题。 性能考虑：对于大型列表，考虑使用虚拟滚动或分页来提高性能。 嵌套 v-for：可以在一个元素内嵌套多个 v-for，但要注意性能和可读性。 1 2 3 4 5 6 7 8 9 10 \u0026lt;template\u0026gt; \u0026lt;div v-for=\u0026#34;(group, groupIndex) in groups\u0026#34; :key=\u0026#34;group.id\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;{{ group.name }}\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(item, itemIndex) in group.items\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt; {{ item.name }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 7. 结合其他指令使用 当位于于同一元素上时，v-for 的优先级低于 v-if。这意味着 v-if 会先于 v-for 被处理，此时 v-if 的条件将无法访问到 v-for 作用域内定义的变量别名。\n1 2 3 4 5 6 7 8 \u0026lt;!--这会抛出错误，因为属性 it 在 v-if 中没有定义--\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p v-for=\u0026#34;it in items\u0026#34; v-if=\u0026#34;it.isActive\u0026#34; :key=\u0026#34;it.id\u0026#34;\u0026gt; {{ it.name }} \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 可以在外层包裹一个 \u0026lt;template\u0026gt; 标签来解决这个问题：\n1 2 3 4 5 6 7 8 9 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;template v-for=\u0026#34;item in items\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt; \u0026lt;p v-if=\u0026#34;item.isActive\u0026#34;\u0026gt; {{ item.name }} \u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 8. 总结 v-for 是 Vue.js 中非常强大且常用的指令，能够帮助开发者高效地渲染列表和处理动态数据。通过理解其语法、作用域以及与其他指令的结合使用，可以更好地利用 v-for 来构建复杂的用户界面。希望本文能帮助你更深入地理解和应用 v-for 指令。\n9. 参考资料 Vue.js 官方文档 - 列表渲染 ","date":"2025-10-11T16:03:55+08:00","permalink":"https://adam-code-line.github.io/p/vue-v-for-guide/","title":"Vue v-for 指令详解"},{"content":"Vue 条件渲染：v-if vs v-show 在 Vue.js 中，条件渲染是构建动态用户界面的重要技术。Vue 提供了两种主要的条件渲染指令：v-if 和 v-show。本文将探讨这两者的区别、使用场景及其底层原理，帮助开发者更好地选择合适的指令来优化应用性能和用户体验。\n1. v-if 的工作原理与使用 v-if 指令用于根据条件动态地添加或移除 DOM 元素。当条件为真时，Vue 会创建并插入元素；当条件为假时，Vue 会销毁并移除元素。\n使用示例 1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p v-if=\u0026#34;isVisible\u0026#34;\u0026gt;这是一个可见的段落。\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; v-if 与 v-else 和 v-else-if v-if 可以与 v-else 和 v-else-if 结合使用，以实现多条件渲染。\n1 2 3 4 5 6 7 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p v-if=\u0026#34;status === \u0026#39;success\u0026#39;\u0026#34;\u0026gt;操作成功！\u0026lt;/p\u0026gt; \u0026lt;p v-else-if=\u0026#34;status === \u0026#39;error\u0026#39;\u0026#34;\u0026gt;操作失败！\u0026lt;/p\u0026gt; \u0026lt;p v-else\u0026gt;操作进行中...\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; v-if 控制多元素的渲染 v-if 也可以用于控制多个元素的渲染，通过包裹在一个父元素中实现。\n1 2 3 4 5 6 \u0026lt;template\u0026gt; \u0026lt;div v-if=\u0026#34;isVisible\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;标题\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;这是一个段落。\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 或者在 Vue 3 中使用 \u0026lt;template\u0026gt; 标签：\n1 2 3 4 \u0026lt;template v-if=\u0026#34;isVisible\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;标题\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;这是一个段落。\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; 2. v-show 的工作原理与使用 v-show 指令也用于条件渲染，但其工作原理与 v-if 不同。v-show 通过设置元素的 CSS display 属性来控制元素的显示与隐藏。当条件为真时，元素会被渲染并显示；当条件为假时，元素仍然存在于 DOM 中，但会被隐藏。\n使用示例 1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p v-show=\u0026#34;isVisible\u0026#34;\u0026gt;这是一个可见的段落。\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 3. v-if vs v-show 的区别 特性 v-if v-show DOM 操作 动态添加和移除元素 仅切换 CSS display 属性 初始渲染性能 较慢，因为需要创建和销毁元素 较快，因为元素始终存在于 DOM 中 适用场景 条件不频繁变化的情况 条件频繁变化的情况 内存占用 较低，因为不需要保留元素 较高，因为元素始终存在于 DOM 中 事件监听 事件监听器会被移除 事件监听器始终存在 4. 选择指南 使用 v-if 当条件不频繁变化，且需要节省内存时。例如，用户登录状态的切换。 使用 v-show 当条件频繁变化，且需要快速切换显示状态时。例如，选项卡切换或模态框显示。 5. 执行顺序 在 Vue 的渲染过程中，当 v-if 和 v-show 同时存在于一个元素的时候，v-if 会优先执行。也就是说，如果 v-if 条件为假，元素不会被渲染，v-show 的条件将不会被评估。但 Vue 官方并不推荐同时使用这两个指令在同一个元素上，因为这可能会导致代码的可读性和维护性降低。\n6. 总结 在选择使用 v-if 还是 v-show 时，开发者需要根据具体的业务场景和性能需求来做出决策。一般来说，v-if 更适合用于条件不频繁变化的场景，而 v-show 则更适合用于需要频繁切换显示状态的场景。通过合理地使用这两种指令，可以有效地提升 Vue 应用的性能和用户体验。\n7. 参考资料 Vue.js 官方文档 - 条件渲染 ","date":"2025-10-11T11:07:50+08:00","permalink":"https://adam-code-line.github.io/p/v-if-v-show/","title":"Vue 条件渲染：v-if vs v-show"},{"content":"Vue 计算属性原理 本文为想学习 Vue 计算属性的前端开发者准备，涵盖 computed 的工作原理及其在 Vue 3 中的实现机制。\n1. 为什么学习计算属性原理 Vue的计算属性能够描述依赖响应式状态复杂逻辑，并且计算属性值会基于其响应式依赖被缓存,只有在computed属性的响应式依赖发生变化时才会重新计算。这种特性使得计算属性在性能优化和代码简洁性方面具有显著优势。\n2. 计算属性的工作原理 计算属性通过 computed 函数创建，接受一个 getter 函数，并返回一个包含 .value 属性的响应式对象。其核心原理如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 function computed(getterOrOptions) { // getter 函数 let getter; // setter 函数 let setter; // 标准化参数 if (isFunction(getterOrOptions)) { // 表面传入的是 getter 函数，不能修改计算属性的值 getter = getterOrOptions; setter = process.env.NODE_ENV !== \u0026#34;production\u0026#34; ? () =\u0026gt; { console.warn(\u0026#34;Write operation failed: computed value is readonly\u0026#34;); } : NOOP; } else { getter = getterOrOptions.get; setter = getterOrOptions.set; } // 数据是否脏的 let dirty = true; // 计算结果 let value; let computed; // 创建副作用函数 const runner = effect(getter, { // 延时执行 lazy: true, // 标记这是一个 computed effect 用于在 trigger 阶段的优先级排序 computed: true, // 调度执行的实现 scheduler: () =\u0026gt; { if (!dirty) { dirty = true; // 派发通知，通知运行访问该计算属性的 activeEffect trigger(computed, \u0026#34;set\u0026#34; /* SET */, \u0026#34;value\u0026#34;); } }, }); // 创建 computed 对象 computed = { __v_isRef: true, // 暴露 effect 对象以便计算属性可以停止计算 effect: runner, get value() { // 计算属性的 getter if (dirty) { // 只有数据为脏的时候才会重新计算 value = runner(); dirty = false; } // 依赖收集，收集运行访问该计算属性的 activeEffect track(computed, \u0026#34;get\u0026#34; /* GET */, \u0026#34;value\u0026#34;); return value; }, set value(newValue) { // 计算属性的 setter setter(newValue); }, }; return computed; } 脏检查：计算属性通过 dirty 标志来判断是否需要重新计算值。当依赖的响应式数据发生变化时，调度器会将 dirty 设置为 true。 依赖收集：当访问计算属性的 .value 时，会调用 track 函数，将当前的副作用函数与该计算属性关联起来。 触发更新：当计算属性的依赖发生变化时，调度器会调用 trigger 函数，通知所有依赖该计算属性的副作用函数重新执行。 缓存机制：计算属性只有在其依赖发生变化时才会重新计算，这通过 dirty 标志实现，从而提高性能。 3. 可写计算属性 计算属性默认是只读的，当尝试修改一个计算属性时，会在开发环境下发出警告，但在某些情况下，我们也可以同时提供getter和setter来创建可写的计算属性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;script setup\u0026gt; import { ref, computed } from \u0026#39;vue\u0026#39; const firstName = ref(\u0026#39;Li\u0026#39;) const lastName = ref(\u0026#39;Hua\u0026#39;) const fullName = computed({ // getter get() { return firstName.value + \u0026#39; \u0026#39; + lastName.value }, // setter set(newValue) { //这里使用的是解构赋值语法 [firstName.value, lastName.value] = newValue.split(\u0026#39; \u0026#39;) } }) \u0026lt;/script\u0026gt; 4. 计算属性与普通方法的区别 计算属性与普通方法的主要区别在于缓存机制。普通方法每次调用都会执行函数体，而计算属性只有在其依赖发生变化时才会重新计算，这使得计算属性在性能上更优。\n计算属性更适合用于依赖响应式数据的复杂逻辑，而普通方法更适合用于不依赖响应式数据的简单逻辑。\n5. 计算属性的实际应用 计算属性在实际开发中有广泛的应用场景，例如：\n表单输入的实时验证：可以使用计算属性来根据输入的值动态计算验证结果，从而实现实时反馈。 复杂数据的展示：在展示复杂数据时，可以使用计算属性来处理数据的格式化和转换，简化模板逻辑。 依赖于多个数据源的计算：当一个值依赖于多个响应式数据时，可以使用计算属性来集中管理这些依赖关系，提高代码的可维护性。 1 2 3 const total = computed(() =\u0026gt; { return items.reduce((sum, item) =\u0026gt; sum + item.price * item.quantity, 0) }) 6. 总结 通过学习 Vue 计算属性的工作原理，开发者可以更好地理解其内部机制，从而在实际开发中更有效地利用这一特性。计算属性不仅提高了代码的简洁性和可读性，还通过缓存机制优化了性能，是 Vue 开发中不可或缺的工具。\n7. 参考资料 Vue.js 官方文档 - 计算属性 深入浅出 Vue 计算属性 computed 的使用与优化 计算属性：Vue3探秘系列— computed的实现原理（六） ","date":"2025-10-09T18:45:11+08:00","permalink":"https://adam-code-line.github.io/p/computed/","title":"Vue 计算属性原理 "},{"content":"Vue 响应式原理 本文为想学习 Vue 响应式系统的前端开发者准备，涵盖 ref 和 reactive 的工作原理及其在 Vue 3 中的实现机制。\n1. 为什么学习响应式原理 学习 Vue 的响应式原理可以帮助开发者更好地理解框架的内部机制，从而在实际开发中更有效地利用这些特性。掌握响应式原理有助于：\n提高调试能力：了解数据是如何变化的，可以更快地定位问题。 优化性能：通过合理使用响应式 API，减少不必要的渲染和计算。 增强代码可读性：清晰的理解数据流动，有助于编写更易于维护的代码。 2. Vue 响应式系统概述 Vue 3 的响应式系统基于 ES6 的 Proxy 对象实现，主要通过 ref 和 reactive 两个 API 来创建响应式数据。\nref：用于创建基本类型的响应式数据，如字符串、数字、布尔值等。它返回一个包含 .value 属性的对象。 reactive：用于创建复杂类型的响应式数据，如对象和数组。 这两个 API 都会追踪数据的变化，并在数据更新时通知相关的组件进行重新渲染。\n3. ref 的工作原理 ref 函数接受一个初始值，并返回一个包含该值的响应式对象。其核心原理如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function ref(initialValue) { const r = { get value() { // 依赖收集 track(r, \u0026#39;value\u0026#39;) return initialValue }, set value(newValue) { initialValue = newValue // 触发更新 trigger(r, \u0026#39;value\u0026#39;) } } return r } 依赖收集：当访问 ref 的 .value 属性时，会调用 track 函数，将当前的副作用函数（如组件的渲染函数）与该属性关联起来。 触发更新：当修改 .value 属性时，会调用 trigger 函数，通知所有依赖该属性的副作用函数重新执行。 4. reactive 的工作原理 reactive 函数接受一个对象，并返回该对象的响应式代理。其核心原理如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function reactive(target) { return new Proxy(target, { get(target, key) { // 依赖收集 track(target, key) return Reflect.get(target, key) }, set(target, key, value) { const result = Reflect.set(target, key, value) // 触发更新 trigger(target, key) return result } }) } 依赖收集：当访问对象的属性时，会调用 track 函数，将当前的副作用函数与该属性关联起来。 触发更新：当修改对象的属性时，会调用 trigger 函数，通知所有依赖该属性的副作用函数重新执行。 5. 依赖追踪与副作用函数 Vue 使用一个全局的 activeEffect 变量来追踪当前正在执行的副作用函数。当副作用函数执行时，activeEffect 会被设置为该函数。当访问响应式数据时，track 函数会将 activeEffect 与该数据关联起来。\n1 2 3 4 5 6 7 8 9 let activeEffect = null function effect(fn) { const effectFn = () =\u0026gt; { activeEffect = effectFn fn() activeEffect = null } effectFn() } effect 函数：接受一个函数作为参数，并将其包装为副作用函数。执行该函数时，会设置 activeEffect，从而实现依赖收集。 track 函数：将 activeEffect 与访问的属性关联起来，存储在一个依赖集合中。 trigger 函数：当属性值发生变化时，遍历依赖集合，执行所有关联的副作用函数。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 const targetMap = new WeakMap() function track(target, key) { if (!activeEffect) return let depsMap = targetMap.get(target) if (!depsMap) { depsMap = new Map() targetMap.set(target, depsMap) } let dep = depsMap.get(key) if (!dep) { dep = new Set() depsMap.set(key, dep) } dep.add(activeEffect) } function trigger(target, key) { const depsMap = targetMap.get(target) if (!depsMap) return const dep = depsMap.get(key) if (dep) { dep.forEach(effect =\u0026gt; effect()) } } targetMap：使用 WeakMap 存储每个响应式对象及其属性的依赖集合。 track 函数：将当前的 activeEffect 添加到对应属性的依赖集合中。 trigger 函数：遍历属性的依赖集合，执行所有副作用函数。 6. ref 与 reactive 的区别与联系 数据类型：ref 适用于基本类型数据，而 reactive 适用于对象和数组。 访问方式：ref 需要通过 .value 访问和修改值，而 reactive 可以直接通过属性访问和修改。 嵌套响应式：reactive 会递归地将嵌套对象转换为响应式，而 ref 只会对其初始值进行响应式处理。 性能：ref 在处理大量基本类型数据时，性能可能优于 reactive，因为后者需要处理更多的代理逻辑。 使用注意： reactive底层是通过Proxy实现的，因此不能直接对reactive对象进行解构赋值，否则会失去响应式特性，同样它也不能监听原始数据类型。相反，ref可以安全地解构，因为它返回的是一个包含.value属性的对象。 7. 总结 通过学习 Vue 的响应式原理，开发者可以更深入地理解框架的工作机制，从而在实际开发中更有效地利用这些特性。掌握 ref 和 reactive 的实现原理，有助于提高调试能力、优化性能，并编写更易于维护的代码。\n8. 参考资料 Vue 3 源码解析 Vue3响应式：ref vs reactive，5分钟消除使用困惑 ","date":"2025-10-09T17:00:49+08:00","permalink":"https://adam-code-line.github.io/p/ref-reactive/","title":"Vue 响应式原理 "},{"content":"TypeScript 学习指南 本文为想系统学习 TypeScript 的前端开发者准备，覆盖从基础类型、配置、进阶类型到在 Vue 项目中使用 TypeScript 的简单实战示例。\n1. 为什么学 TypeScript 静态类型可以在编译期发现很多常见错误，提高代码可维护性。 与现代 IDE（例如 VS Code）结合，能获得更好的智能提示、重构支持和文档提示。 2. 快速开始 1 2 3 4 # 初始化项目 pnpm init -y pnpm add -D typescript npx tsc --init 这会生成 tsconfig.json。\n一个常见的 tsconfig.json 最小配置：\n1 2 3 4 5 6 7 8 9 10 11 12 { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;ES2020\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;ESNext\u0026#34;, \u0026#34;moduleResolution\u0026#34;: \u0026#34;Node\u0026#34;, \u0026#34;strict\u0026#34;: true, \u0026#34;jsx\u0026#34;: \u0026#34;preserve\u0026#34;, \u0026#34;esModuleInterop\u0026#34;: true, \u0026#34;skipLibCheck\u0026#34;: true, \u0026#34;forceConsistentCasingInFileNames\u0026#34;: true } } 3. 基础类型示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 原始类型 let s: string = \u0026#39;hello\u0026#39; let n: number = 123 let b: boolean = true // 数组与元组 let arr: number[] = [1,2,3] let tup: [string, number] = [\u0026#39;age\u0026#39;, 18] // 联合类型与类型别名 type ID = string | number let id: ID = \u0026#39;abc\u0026#39; // 接口与类型 interface User { id: ID; name: string } const user: User = { id: \u0026#39;u1\u0026#39;, name: \u0026#39;Alice\u0026#39; } // 函数类型 function add(a: number, b: number): number { return a + b } 4. 进阶类型 泛型（Generics） 映射类型（Mapped Types） 条件类型（Conditional Types） 泛型示例：\n1 2 function identity\u0026lt;T\u0026gt;(arg: T): T { return arg } const s = identity\u0026lt;string\u0026gt;(\u0026#39;hi\u0026#39;) 5. 在 Vue 中使用 TypeScript 推荐使用 script setup lang=\u0026quot;ts\u0026quot;。 在 Vite + Vue 项目中，shims-vue.d.ts 可能需要声明 Vue 文件支持： 1 2 3 4 5 declare module \u0026#39;*.vue\u0026#39; { import { DefineComponent } from \u0026#39;vue\u0026#39; const component: DefineComponent\u0026lt;{}, {}, any\u0026gt; export default component } 组件示例：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { defineProps } from \u0026#39;vue\u0026#39; interface Props { title: string } const props = defineProps\u0026lt;Props\u0026gt;() \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;h1\u0026gt;{{ props.title }}\u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; 6. 常见模式与技巧 使用 as const 固定字面量类型。 使用 unknown 代替 any 做更严格的类型收敛。 使用 ReturnType\u0026lt;\u0026gt;, Partial\u0026lt;\u0026gt;, Required\u0026lt;\u0026gt; 等工具类型提高复用性。 7. 配合工具链 ESLint 与 TypeScript: 使用 @typescript-eslint/parser 和 @typescript-eslint/eslint-plugin。 编辑器：确保安装 TypeScript 相关插件并在项目中使用本地 TypeScript（避免全局版本不一致）。 8. 练习任务 把一个小型 JS 项目迁移到 TypeScript（从 --strict 放宽到逐步开启 strict 规则）。 写一个简单的泛型工具函数并写测试（Vitest）。 9. 参考资源 TypeScript 官方文档 TypeScript Deep Dive Vue + TypeScript 官方指南 TypeScript ESLint ","date":"2025-10-01T11:35:10+08:00","image":"https://adam-code-line.github.io/p/typescript-learning-guide/cover_hu_eee5813ff9235310.jpg","permalink":"https://adam-code-line.github.io/p/typescript-learning-guide/","title":"TypeScript"},{"content":"Vue 学习指南 这篇指南面向想系统学习 Vue 3 的开发者，覆盖从环境搭建、组合式 API、组件设计、路由、状态管理到测试与部署的简单实用示例和练习。\n1. 开发环境与快速启动 推荐使用 Node.js（16+）与 Vite 创建项目：\n1 2 3 4 5 6 7 8 # 全局安装（可选） npm install -g pnpm # 使用 pnpm 创建项目 pnpm create vite@latest my-vue-app -- --template vue-ts cd my-vue-app pnpm install pnpm dev 打开 http://localhost:5173 即可预览。\n2. 核心概念（简要） 组件（Components）：UI 的可复用单元。 响应式（Reactivity）：ref、reactive 提供响应式数据。 生命周期钩子：onMounted、onUnmounted 等。 组合式 API（Composition API）：使用 setup() 或 script setup 来组织逻辑。 3. 组合式 API 基本示例 以下示例展示计数器的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count: {{ count }}\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { ref } from \u0026#39;vue\u0026#39; const count = ref(0) function increment() { count.value++ } \u0026lt;/script\u0026gt; 4. 组件传参与事件 父组件向子组件传递 props，并通过 emit 触发事件：\nChild.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;onClick\u0026#34;\u0026gt;{{ label }}\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { defineProps, defineEmits } from \u0026#39;vue\u0026#39; const props = defineProps\u0026lt;{ label: string }\u0026gt;() const emit = defineEmits\u0026lt;{ (e: \u0026#39;clicked\u0026#39;): void }\u0026gt;() function onClick() { emit(\u0026#39;clicked\u0026#39;) } \u0026lt;/script\u0026gt; Parent.vue\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;template\u0026gt; \u0026lt;Child label=\u0026#34;Click me\u0026#34; @clicked=\u0026#34;handle\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import Child from \u0026#39;./Child.vue\u0026#39; function handle() { console.log(\u0026#39;child clicked\u0026#39;) } \u0026lt;/script\u0026gt; 5. 路由（Vue Router）基础 安装并配置 Vue Router：\n1 pnpm add vue-router@4 src/router/index.ts 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 import { createRouter, createWebHistory } from \u0026#39;vue-router\u0026#39; import Home from \u0026#39;../views/Home.vue\u0026#39; import About from \u0026#39;../views/About.vue\u0026#39; const routes = [ { path: \u0026#39;/\u0026#39;, component: Home }, { path: \u0026#39;/about\u0026#39;, component: About }, ] export const router = createRouter({ history: createWebHistory(), routes, }) 在 main.ts 中挂载：\n1 2 3 4 5 import { createApp } from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import { router } from \u0026#39;./router\u0026#39; createApp(App).use(router).mount(\u0026#39;#app\u0026#39;) 6. 状态管理（Pinia） 使用 Pinia 取代 Vuex：\n1 pnpm add pinia 示例 store：\n1 2 3 4 5 6 7 8 9 // stores/counter.ts import { defineStore } from \u0026#39;pinia\u0026#39; import { ref } from \u0026#39;vue\u0026#39; export const useCounter = defineStore(\u0026#39;counter\u0026#39;, () =\u0026gt; { const count = ref(0) function increment() { count.value++ } return { count, increment } }) 在主应用中挂载 Pinia：\n1 2 import { createPinia } from \u0026#39;pinia\u0026#39; createApp(App).use(createPinia()).use(router).mount(\u0026#39;#app\u0026#39;) 组件中使用：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { useCounter } from \u0026#39;@/stores/counter\u0026#39; const counter = useCounter() \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{{ counter.count }}\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026#34;counter.increment\u0026#34;\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 7. 常用工具与测试 开发工具：Vite、ESLint、Prettier、TypeScript。 测试：Vitest + @vue/test-utils。 简单的 Vitest 测试示例：\n1 2 3 4 5 6 7 8 9 10 11 // tests/example.spec.ts import { describe, it, expect } from \u0026#39;vitest\u0026#39; import { mount } from \u0026#39;@vue/test-utils\u0026#39; import Hello from \u0026#39;../src/components/HelloWorld.vue\u0026#39; describe(\u0026#39;Hello\u0026#39;, () =\u0026gt; { it(\u0026#39;renders properly\u0026#39;, () =\u0026gt; { const wrapper = mount(Hello) expect(wrapper.text()).toContain(\u0026#39;Hello\u0026#39;) }) }) 8. 部署与发布建议 小型项目可以使用 Vercel 或 Netlify 直接部署，无需复杂配置。 打包命令： 1 2 3 pnpm build # 本地预览 pnpm preview 9. 参考资源 Vue 3 官方文档 Vue Router 文档 Pinia 文档 Vitest 文档 ","date":"2025-10-01T10:52:24+08:00","image":"https://adam-code-line.github.io/p/vue-learning-guide/cover_hu_1d9a212cbcfa3493.jpg","permalink":"https://adam-code-line.github.io/p/vue-learning-guide/","title":"Vue"},{"content":"前端学习路线 写博客是把自己学到的知识沉淀并分享给别人的好方法。本文模仿项目中的风格，给出一套清晰的前端学习路线，适用于刚入门的同学，也适合想系统提升的开发者。\n为什么需要一条明确的学习路线 前端技术栈庞杂，工具和框架迭代快。如果没有系统性的学习计划，容易在碎片化的资料中迷失，不知下一步该学什么。一个合理的路线能帮助你建立知识体系、提升可迁移能力，并且尽早能做出完整的项目。\n学习路线总览 阶段 0：准备 (工具, 英语, 开发环境) 阶段 1：基础前端三剑客 (HTML/CSS/JavaScript) 阶段 2：前端三件套 (框架, 路由, 状态管理) 阶段 3：进阶 (TypeScript, 构建工具, 性能, 无障碍) 阶段 4：全栈与工程化 (后端基础, 部署, 测试) 阶段 5：项目驱动学习与实习面试准备 下面逐步展开每个阶段的推荐内容与练习方式。\n阶段 0：准备 安装并熟练使用一套编辑器 (VS Code 推荐) 和常用插件 (格式化, ESLint, vue(official)). 学习使用 Git 与 GitHub，掌握基本的 push、分支与 Pull Request 流程。 提升阅读英文文档的能力，前端优秀资源大多以英文为主。 阶段 1：基础 (约 1–2 个月) HTML: 语义化标签, 表单, 可访问性 (ARIA) 基础. CSS: 盒模型, Flexbox, Grid, 响应式设计, 常见布局技巧. JavaScript: 语法, 闭包, 原型链, 异步 (Promise, async/await), 模块化. 练习：实现若干静态页面（登录页、博客列表页、卡片布局），并尝试移动端适配。\n阶段 2：前端三件套 (约 1–3 个月) 框架: Vue 3 (或 React/Angular, 视团队与个人喜好). 掌握组件, 组合式 API (Vue 的 script setup), 生命周期, Props/Emit. 路由: 客户端路由的使用与懒加载 (例如 Vue Router). 状态管理: Pinia (Vue) 或 Redux (React) 的基本模式与实践. 练习：基于框架实现一个小型应用（Todo、简单博客、记账工具），包含路由和状态管理。\n阶段 3：进阶 (约 2–4 个月) TypeScript: 类型系统, 泛型, 声明文件 (.d.ts), 与现有 JS 项目迁移技巧. 构建工具: Vite / Webpack / Rollup 的基础配置与性能优化思路. CSS 工具: TailwindCSS, 预处理器 (Sass/LESS), CSS Modules. 性能与可访问性: 懒加载, code-splitting, 图片优化, 无障碍 (a11y) 最佳实践. 练习：给已有项目引入 TypeScript，做一次性能审计并逐项优化。\n阶段 4：全栈与工程化 (约 2–4 个月) 后端基础: RESTful API, GraphQL, 基础数据库 (Postgres, MongoDB) 概念. 部署: Docker, CI/CD (GitHub Actions), 托管平台 (Vercel, Netlify, 云主机). 测试: 单元测试 (Vitest/Jest), 端到端测试 (Cypress). 监控与日志: Sentry, 性能监控 (Lighthouse). 练习：把应用后端作为简单服务部署，使用 GitHub Actions 做自动化部署。\n阶段 5：项目驱动学习与面试准备 用项目驱动: 选择一个中等复杂度的项目 (支持用户登录, 数据持久化, 文件上传, 搜索/筛选), 把学习的技术整合进来. 写技术博客与读源码: 把你遇到的问题记录成文章, 帮助他人也帮助自己. 面试题训练: 算法基础, 网络/浏览器原理, 系统设计的简要理解. 学习建议 输出优先于输入: 能把学到的知识写成文章或实现成项目, 才算真正掌握. 定期复盘: 每 2–4 周总结学习进度, 调整计划. 社区与开源: 参与讨论, PR, 能快速提升工程能力. 参考资源（部分） MDN (HTML/CSS/JS) Vue 官方文档 / React 官方文档 Vite, Tailwind, TypeScript 官方指南 学习路线图 ⬇️ 下载 前端学习路线图(出处:https://front-talk.com/roadmap) ","date":"2025-09-30T11:04:33+08:00","image":"https://adam-code-line.github.io/p/frontend-learning-path/cover_hu_ffc67913452221a7.jpg","permalink":"https://adam-code-line.github.io/p/frontend-learning-path/","title":"前端学习路线"},{"content":"第一次写博客 在很早之前就有过写博客的想法，但是一直没有付诸行动。直到最近，终于决定开始记录自己的生活和学习经历。一开始本来是想着自己写一个博客系统，但是考虑到时间和精力的问题，最终选择了使用Hugo这个静态网站生成器。经过一番折腾，终于搭建好了自己的个人博客网站。希望自己以后能够坚持更新，分享更多有趣的内容和有用的知识。\n","date":"2025-09-21T23:35:33+08:00","image":"https://adam-code-line.github.io/p/life/cover_hu_dde4c1f358e5b772.jpg","permalink":"https://adam-code-line.github.io/p/life/","title":"我的第一篇文章"}]