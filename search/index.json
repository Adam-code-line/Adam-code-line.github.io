[{"content":"前端开发扫盲 本文的目的是帮助零基础的读者了解前端开发的基本概念和技术栈，扫除入门障碍，为进一步学习打下坚实基础。本文也会回答“前端是什么”“前端开发需要掌握哪些核心技术”等基本问题。\n对前端的错误认知 介绍前端之前，先来澄清一些对前端的常见误解：\n前端只是网页设计：虽然前端开发涉及到网页的视觉设计，但它不仅仅是设计。前端开发还包括编写代码实现网页的结构、样式和交互功能,也涉及对网页的性能优化和用户体验的提升等方面。 前端不需要编程：前端开发需要掌握多种编程语言和技术，如 HTML、CSS 和 JavaScript，这些都是编程的基础,而且前端开发的工作中也会涉及到一些编程逻辑和算法。 前端开发很简单：虽然入门相对容易，但前端开发的深度和广度都很大，要成为一名优秀的前端开发者，需要深入理解各种技术和工具，尤其是到中后期学习框架的时候，需要深入学习框架的规范和各种使用方法，学习难度相对比较大。 前端和后端是完全独立的：前端和后端是相互依赖的，前端需要与后端协作，确保数据的正确传输和处理，在一些工作中可能会涉及到后端的知识，也会有全栈开发的情况。 什么是前端？ 要回答“前端是什么”,得先说说前端的概念,前端(Front-end)是网站前台部分，指运行在PC端、移动端等浏览器上并直接展现给用户浏览并提供给用户交互的网页界面。换句话说，你在网站或应用程序的屏幕上能看到的所有内容都属于前端。你访问的网站的图片、文字、可点击的按钮、导航栏等，以及你在手机上看到的应用界面，用手势放大缩小的图片，播放的视频等，都是前端的一部分。前端开发就是在构建所有的这些内容和功能，也即创造了你在屏幕上看到的外观和触摸到的体验。\n前端开发的职责 前端开发的主要职责包括以下几个方面：\n用户界面设计与实现：前端开发者负责将设计师提供的视觉设计稿转化为实际可用的网页界面，确保界面美观且符合用户体验原则。 响应式设计：确保网页在不同设备和屏幕尺寸上都能良好显示和操作，提供一致的用户体验。 交互功能开发：通过编写代码实现网页的交互功能，如按钮点击、表单提交、动态内容更新等，使用户能够与网页进行互动。 性能优化：前端开发者需要优化网页的加载速度和运行效率，提升用户体验。 跨浏览器兼容性：确保网页在不同浏览器上都能正常工作，解决浏览器差异带来的问题。 与后端协作：前端开发者需要与后端开发者紧密合作，确保前后端数据的正确传输和处理。 前端开发的步骤 前端开发通常包括以下几个步骤：\n需求分析：理解项目需求，明确网页的功能和设计要求。 设计阶段：与设计师合作，确定网页的视觉风格和布局。 开发阶段：编写代码实现网页的结构、样式和交互功能。 测试阶段：对网页进行功能测试和兼容性测试，确保其在不同环境下正常运行。 部署阶段：将开发完成的网页发布到服务器，供用户访问。 维护与更新：根据用户反馈和需求变化，持续优化和更新网页内容和功能。 前端开发的核心技术 相比较与后端，前段的技术更迭要更为迅速，可能每一天都有新的前端框架和工具出现。尽管如此，前端开发的核心技术还是比较稳定的，主要包括以下三大核心技术，也被称为 前端三剑客 :\n⬇️ 下载 前端三剑客(出处:https://blog.csdn.net/askf01/article/details/132234956) HTML（超文本标记语言） HTML 是构建网页的基础，用于定义网页的结构和内容。它使用标签来标识不同类型的内容，如标题、段落、链接、图像等。通俗点说，HTML负责网页的架构，是前端的\u0026quot;骨架\u0026quot;。\nHTML 的基本结构\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is a simple HTML document.\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在上面的例子中：\n\u0026lt;!DOCTYPE html\u0026gt; 声明文档类型，告诉浏览器这是一个 HTML5 文档。 \u0026lt;html\u0026gt; 标签是整个 HTML 文档的根元素，包含了所有其他元素。 \u0026lt;head\u0026gt; 标签包含了文档的元数据，如字符集、视口设置和标题。 \u0026lt;body\u0026gt; 标签包含了网页的可见内容，如标题和段落。 \u0026lt;h1\u0026gt; 标签表示一级标题，\u0026lt;p\u0026gt; 标签表示段落。 meta 标签用于提供关于 HTML 文档的信息，如字符编码和视口设置。 HTML 通过一系列的标签定义了网页中元素，比如哪个是标题，哪个是段落，哪里放图片，为前端搭建了基本的结构和内容。\nCSS（层叠样式表） CSS 用于控制网页的外观和布局。通过 CSS，开发者可以设置颜色、字体、间距、对齐方式等，使网页更具吸引力和可读性，也可以控制网页的布局，使得网页在不同的屏幕尺寸和设备上都能保持良好的视觉体验，也即响应式设计。简单的说，CSS 负责网页的样式、美化，是前端的\u0026quot;皮肤、衣服\u0026quot;。\nCSS 的基本用法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { background-color: #f0f0f0; font-family: Arial, sans-serif; } h1 { color: #333; } p { color: #666; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is a simple HTML document with CSS styling.\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在上面的例子中：\n\u0026lt;style\u0026gt; 标签用于在 HTML 文档中嵌入 CSS 样式。 body 选择器设置了网页的背景颜色和字体。 h1 选择器设置了标题的颜色。 p 选择器设置了段落的颜色。 font-family 属性定义了文本的字体样式。 background-color 属性设置了网页的背景颜色。 CSS 通过定义样式规则，调整网页的布局，修改元素的样式，实现丰富的视觉效果\nJavaScript JavaScript 是一种编程语言，用于为网页添加交互功能。通过 JavaScript，开发者可以实现动态内容更新、表单验证、动画效果等，使用户体验更加丰富，让网页不仅仅是静态的内容，而是可以响应用户的操作。总的来说，JavaScript 负责网页的交互，是前端的\u0026quot;动作\u0026quot;。\nJavaScript 的基本用法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { background-color: #f0f0f0; font-family: Arial, sans-serif; } h1 { color: #333; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;button onclick=\u0026#34;showMessage()\u0026#34;\u0026gt;Click Me\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; function showMessage() { alert(\u0026#34;Hello, World!\u0026#34;); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在上面的例子中：\n\u0026lt;script\u0026gt; 标签用于在 HTML 文档中嵌入 JavaScript 代码。 showMessage 函数定义了一个弹出消息的功能。 \u0026lt;button\u0026gt; 标签创建了一个按钮，onclick 属性绑定了点击事件，当按钮被点击时，会调用 showMessage 函数，弹出一个消息框。 JavaScript 通过编写脚本，实现网页的动态交互功能，让页面不仅仅是静态的内容，而是可以响应用户的操作。\n下图展示了前端三大核心技术各自的职责与关系：\n⬇️ 下载 前端三剑客职责与关系(出处:https://blog.csdn.net/weixin_46913665/article/details/124391067) 前端开发的常用工具和框架 除了上述核心技术外，前端开发还依赖于许多工具和框架来提高开发效率和代码质量。以下是一些常用的工具和框架：\n版本控制系统（如 Git）：用于跟踪代码的更改，协作开发和管理项目历史，在多人协作开发的环境中尤为重要。在开发过程也会使用到如 GitHub、Gitee代码托管平台来存储和管理代码仓库，这也是一个开发者必须掌握的技能。\n包管理器（如 npm、Yarn、pnpm）：用于管理项目依赖的库和工具，简化安装和更新过程,一般建议新手先使用npm,等到后面熟悉后可以尝试其他的包管理器。\n前端框架（如 React、Vue、Angular）：这些框架提供了结构化的方法来构建复杂的用户界面，简化开发过程，提高效率，框架的学习是一个长期的且比较困难的过程，需要等到对前端知识有一定的掌握后再深入学习。\n构建工具（如 Webpack、Vite）：用于打包和优化前端代码，提高加载速度和性能。\n调试工具（如 Chrome DevTools）：用于调试和分析网页性能，帮助开发者快速定位和修复问题。\n本文重在介绍前端开发的基础知识，以上提到的工具和框架只是冰山一角，随着前端技术的发展，还有许多其他有用的工具和框架可供选择。\n学习资源推荐 MDN Web Docs：全面的前端技术文档和教程。 黑马程序员前端入门视频：适合初学者的中文前端视频教程。 黑马程序员前端JavaScript入门到精通：系统学习JavaScript的中文视频教程。 结语 相较于后端，前端开发的上手难度要更为简单，学习了基本的 HTML、CSS 和 JavaScript 知识，就可以开始构建简单的网页。但是如果想要成为一名优秀的前端开发者，还需要学习多种工具和框架的使用，并不断实践和积累经验。前端的知识体系庞大且更新迅速，保持学习的热情和持续的练习是不被淘汰的关键。希望本文能帮助你扫清前端开发的入门障碍，开启你的前端学习之旅！\n","date":"2025-10-19T14:18:40+08:00","permalink":"https://adam-code-line.github.io/p/frontend-development-basics/","title":"前端开发扫盲"},{"content":"Web API API（Application Programming Interface，应用程序编程接口）在软件程序开发中扮演着重要角色。本文将简单介绍什么是API，特别是Web API的概念、类型及其在前端开发中的简单应用。\n1. 什么是API API是一组定义和协议，允许不同软件应用程序之间进行通信和交互。API抽象了复杂的代码，通过API，开发者可以直接使用已经封装好的代码功能，而无需从头开始编写代码功能的底层逻辑。\n2. Web API的类型 Web API是通过HTTP协议进行通信的API，支持多种操作方式,并支持各种数据格式（如JSON、XML），它可以分成两大类： 浏览器API 和 第三方API。\n2.1 浏览器API 浏览器API是由浏览器提供的接口，允许开发者访问和操作浏览器的功能和资源。常见的浏览器API包括：\nDOM API：用于操作HTML和XML文档的结构、样式和内容。 Fetch API：用于发起网络请求，替代传统的XMLHttpRequest。 Canvas API：用于在网页上绘制图形和动画。 Geolocation API：用于获取用户的地理位置信息。 Web Storage API：用于在浏览器中存储数据（如localStorage和sessionStorage）。 WebSocket API：用于实现实时双向通信。 Media API：用于处理音频和视频内容。 2.2 第三方API 第三方API是由外部服务提供的接口，允许开发者访问这些服务的功能和数据。常见的第三方API包括：\n社交媒体API：如Facebook Graph API、Twitter API，用于访问社交媒体平台的数据和功能。 地图API：如Google Maps API、Mapbox API，用于集成地图和地理位置服务。 支付API：如Stripe API、PayPal API，用于处理在线支付。 天气API：如OpenWeatherMap API，用于获取天气信息。 数据API：如RESTful API、GraphQL API，用于访问各种数据服务。 3. 使用Web API的示例 使用JavaScript编写的简单示例，展示如何使用一些常见的Web API。\n3.1 使用Fetch API发起网络请求 1 2 3 4 fetch(\u0026#39;https://api.example.com/data\u0026#39;) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; console.log(data)) .catch(error =\u0026gt; console.error(\u0026#39;Error:\u0026#39;, error)); 3.2 使用Geolocation API获取用户位置 1 2 3 4 5 6 7 8 if (navigator.geolocation) { navigator.geolocation.getCurrentPosition(position =\u0026gt; { console.log(\u0026#39;Latitude:\u0026#39;, position.coords.latitude); console.log(\u0026#39;Longitude:\u0026#39;, position.coords.longitude); }); } else { console.log(\u0026#39;Geolocation is not supported by this browser.\u0026#39;); } 3.3 使用Canvas API绘制图形 1 2 3 4 const canvas = document.getElementById(\u0026#39;myCanvas\u0026#39;); const ctx = canvas.getContext(\u0026#39;2d\u0026#39;); ctx.fillStyle = \u0026#39;green\u0026#39;; ctx.fillRect(10, 10, 150, 100); 3.4 使用LocalStorage存储数据 1 2 3 4 5 6 7 8 9 // 存储数据 localStorage.setItem(\u0026#39;username\u0026#39;, \u0026#39;JohnDoe\u0026#39;); // 获取数据 const username = localStorage.getItem(\u0026#39;username\u0026#39;); console.log(username); // 输出: JohnDoe // 删除数据 localStorage.removeItem(\u0026#39;username\u0026#39;); // 清除所有数据 localStorage.clear(); 3.5 使用第三方API（以OpenWeatherMap为例） 1 2 3 4 fetch(\u0026#39;https://api.openweathermap.org/data/2.5/weather?q=London\u0026amp;appid=YOUR_API_KEY\u0026#39;) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; console.log(data)) .catch(error =\u0026gt; console.error(\u0026#39;Error:\u0026#39;, error)); 4. 总结 Web API在现代前端开发中扮演着至关重要的角色。通过利用浏览器API和第三方API，开发者可以创建功能丰富、交互性强的Web应用程序。理解和掌握这些API的使用方法，将大大提升开发效率和用户体验。\n5. 参考资料 MDN Web Docs - 客户端Web API What is an API? ","date":"2025-10-16T12:39:50+08:00","permalink":"https://adam-code-line.github.io/p/web-api/","title":"Web API"},{"content":"Nuxt 基础总述 Nuxt 是一个基于 Vue.js 的开源全栈式框架，旨在简化服务端渲染（SSR）和静态网站生成（SSG）的开发过程。它提供了许多开箱即用的功能，如自动路由、状态管理、API 集成等，使开发者能够更专注于业务逻辑而非配置细节。\n1. Nuxt 的核心特性 服务端渲染（SSR）：提升首屏加载速度和 SEO 性能。 静态网站生成（SSG）：预渲染页面，适合内容驱动型网站。 自动路由：基于文件系统的路由，根据 pages/ 目录结构定义路由，无需手动配置。 自动导入：Nuxt 自动导入组件、组合式函数和 Vue.js API，以便在你的应用中无需显式导入即可使用。 TypeScript 支持：内置对 TypeScript 的支持，提升代码质量。 Vue 3 支持：兼容最新的 Vue 3 特性和生态。 组合式 API：支持 Vue 3 的组合式 API，提升代码复用性。 SEO 优化：内置对元标签和动态路由的支持，提升搜索引擎排名。 开发者工具：集成 Vue Devtools，提升调试体验。 支持多种渲染模式：如 SPA、SSR、SSG 和混合模式，满足不同项目需求。 强大的配置选项：通过 nuxt.config.js 文件灵活配置项目。 2. Nuxt 的安装与快速开始 创建项目 前置条件：\nNode.js（版本 20 及以上）,推荐使用LTS（长期支持）版本 npm 、yarn 或 pnpm 包管理器 文本编辑器（官方推荐 VSCode）配合官方Vue(Official)插件使用 终端 在终端创建项目：\n使用npm 、yarn 或 pnpm创建项目： 1 npm/yarn/pnpm create nuxt \u0026lt;project-name\u0026gt; 在VSCode中打开项目文件夹：\n1 code \u0026lt;project-name\u0026gt; 1 cd \u0026lt;project-name\u0026gt; 注意：\u0026lt;project-name\u0026gt; 替换为你的项目名称。\n运行项目 进入项目目录后，安装依赖并启动开发服务器：\n1 npm/yarn/pnpm run dev 打开浏览器访问 http://localhost:3000，即可看到 Nuxt 应用的欢迎页面。\n3. Nuxt 项目结构 Nuxt4官方项目结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 . ├── .nuxt/ # Nuxt 自动生成的文件夹 ├── .output/ # Nuxt 构建输出目录 ├── app/ │ ├── assets/ # 静态资源（CSS、图片等） │ ├── components/ # Vue 组件 │ ├── composables/ # 可复用的组合式函数 │ ├── layouts/ # 布局组件 │ ├── middleware/ # 中间件 │ ├── pages/ # 页面组件 │ ├── plugins/ # 插件 │ ├── utils/ # 工具函数 │ ├── app.vue/ # 根组件 │ ├── app.config.ts # 应用配置 │ └── error.vue # 错误页面组件 ├── content/ # 内容文件（如 Markdown） ├── modules/ # 公共模块 ├── node_modules/ # 依赖包 ├── public/ # 公共静态文件 ├── server/ # 服务器端代码（API 路由等） ├── shared/ # 共享代码 ├── .env # 环境变量文件 ├── .gitignore # Git 忽略文件 ├── .nuxtignore # Nuxt 忽略文件 ├── .nuxtrc # Nuxt 配置文件 ├── nuxt.config.ts # Nuxt 配置文件 ├── package.json # 项目配置文件 └── tsconfig.json # TypeScript 配置文件 4. Nuxt 的核心概念 页面与路由 在 pages/ 目录下创建 Vue 文件，Nuxt 会自动根据文件结构生成路由。例如：\n1 2 3 4 5 6 pages/ ├── index.vue # 路由：/ ├── about.vue # 路由：/about └── blog/ ├── index.vue # 路由：/blog └── [id].vue # 动态路由：/blog/:id 布局 布局组件位于 layouts/ 目录，用于定义应用的整体结构。默认布局文件为 default.vue，可以通过在页面组件中使用 definePageMeta 指定不同的布局：\n1 2 3 4 5 \u0026lt;script setup\u0026gt; definePageMeta({ layout: \u0026#39;custom\u0026#39; // 使用 layouts/custom.vue 作为布局 }) \u0026lt;/script\u0026gt; 组件 组件存放在 components/ 目录，可以在页面和布局中直接使用。Nuxt 支持自动导入组件，无需手动导入：\n1 2 3 \u0026lt;template\u0026gt; \u0026lt;MyComponent /\u0026gt; \u0026lt;/template\u0026gt; 组合式函数 组合式函数存放在 composables/ 目录，用于封装可复用的逻辑。例如：\n1 2 3 4 5 6 7 8 9 10 // composables/useCounter.ts export function useCounter() { //这里ref被nuxt自动导入 const count = ref(0); const increment = () =\u0026gt; { count.value++; }; return { count, increment }; } 插件 插件存放在 plugins/ 目录，用于扩展 Nuxt 功能。例如，注册第三方库：\n1 2 3 4 5 6 7 8 9 // plugins/axios.ts import axios from \u0026#39;axios\u0026#39;; export default defineNuxtPlugin(() =\u0026gt; { return { provide: { axios: axios.create({ baseURL: \u0026#39;https://api.example.com\u0026#39; }) } }; }); 中间件 中间件存放在 middleware/ 目录，用于在页面渲染前执行逻辑。例如，身份验证：\n1 2 3 4 5 6 7 // middleware/auth.ts export default defineNuxtRouteMiddleware((to, from) =\u0026gt; { const isAuthenticated = false; // 示例：实际应检查用户状态 if (!isAuthenticated \u0026amp;\u0026amp; to.path !== \u0026#39;/login\u0026#39;) { return navigateTo(\u0026#39;/login\u0026#39;); } }); 配置文件 nuxt.config.ts：项目的主要配置文件，用于配置模块、插件、路由等。 1 2 3 4 5 6 7 8 // nuxt.config.ts export default defineNuxtConfig({ modules: [\u0026#39;@nuxt/content\u0026#39;, \u0026#39;@nuxtjs/axios\u0026#39;], css: [\u0026#39;~/assets/css/main.css\u0026#39;], build: { transpile: [\u0026#39;some-dependency\u0026#39;] } }); runtimeConfig 用于存储运行时配置,可以将环境变量等值暴露给应用其他部分。默认情况下, runtimeConfig 中的值不会暴露给客户端,除非将其放在 public 对象中。\n1 2 3 4 5 6 7 export default defineNuxtConfig({ runtimeConfig: { public: { apiBase: process.env.API_BASE || \u0026#39;https://api.example.com\u0026#39; } } }); runtimeConfig 中的值可以通过 useRuntimeConfig 组合式函数访问，且可以通过环境变量(.env)覆盖：\n1 2 const config = useRuntimeConfig(); console.log(config.public.apiBase); // 访问公共配置 .env：环境变量文件，用于存储敏感信息，如 API 密钥。 1 2 API_BASE=https://api.example.com API_KEY=your_api_key_here tsconfig.json：TypeScript 配置文件。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;ESNext\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;ESNext\u0026#34;, \u0026#34;moduleResolution\u0026#34;: \u0026#34;Node\u0026#34;, \u0026#34;strict\u0026#34;: true, \u0026#34;jsx\u0026#34;: \u0026#34;preserve\u0026#34;, \u0026#34;esModuleInterop\u0026#34;: true, \u0026#34;skipLibCheck\u0026#34;: true, \u0026#34;forceConsistentCasingInFileNames\u0026#34;: true, \u0026#34;baseUrl\u0026#34;: \u0026#34;.\u0026#34;, \u0026#34;paths\u0026#34;: { \u0026#34;~/*\u0026#34;: [\u0026#34;./*\u0026#34;], \u0026#34;@/*\u0026#34;: [\u0026#34;./*\u0026#34;] }, \u0026#34;types\u0026#34;: [\u0026#34;@nuxt/types\u0026#34;, \u0026#34;@nuxtjs/axios\u0026#34;] }, \u0026#34;exclude\u0026#34;: [\u0026#34;node_modules\u0026#34;, \u0026#34;.nuxt\u0026#34;, \u0026#34;dist\u0026#34;] } package.json：项目依赖和脚本配置文件。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 { \u0026#34;name\u0026#34;: \u0026#34;my-nuxt-app\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;nuxt dev\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;nuxt build\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;nuxt start\u0026#34;, \u0026#34;generate\u0026#34;: \u0026#34;nuxt generate\u0026#34; }, \u0026#34;dependencies\u0026#34;: { \u0026#34;nuxt\u0026#34;: \u0026#34;^4.0.0\u0026#34;, \u0026#34;@nuxt/content\u0026#34;: \u0026#34;^2.0.0\u0026#34;, \u0026#34;@nuxtjs/axios\u0026#34;: \u0026#34;^5.13.6\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;typescript\u0026#34;: \u0026#34;^4.5.4\u0026#34; } } app.config.ts：应用程序配置文件，用于暴露构建时可确定的公共变量。 1 2 3 4 5 6 7 8 9 10 11 // app/app.config.ts export default defineAppConfig({ title: \u0026#39;Hello Nuxt\u0026#39;, theme: { dark: true, colors: { primary: \u0026#39;#ff0000\u0026#39;, secondary: \u0026#39;#00ff00\u0026#39;, } } }) app.config.ts 中的配置可以通过 useAppConfig 组合式函数访问，但与runtimeConfig 中的配置不同，app.config.ts 中的配置在构建时是静态的，而 runtimeConfig 中的配置可以在运行时动态变化，且app.config.ts中的变量不可以通过环境变量(.env)覆盖。\n1 2 const appConfig = useAppConfig(); console.log(appConfig.title); // 访问应用标题 5. 总结 Nuxt 是一个功能强大的全栈式框架，十分适合用于构建现代 Web 应用,但Nuxt中有着许多约定俗成的规则，需要花费时间去熟悉和掌握，具有一定的学习成本。通过本文的介绍，希望你对 Nuxt 有了一个初步的了解，能够开始使用它来构建你的下一个项目。\n6. 参考资料 Nuxt 官方文档 Vue.js 官方文档 TypeScript 官方文档 Vite 官方文档 Node.js 官方文档 ","date":"2025-10-12T11:51:13+08:00","permalink":"https://adam-code-line.github.io/p/nuxt/","title":"Nuxt 基础总述"},{"content":"JavaScript 基础知识入门 JavaScript 是一种广泛用于网页开发的编程语言。本文将介绍 JavaScript 的基本概念、语法及其应用，帮助初学者快速入门。\n1. JavaScript 基本概念 JavaScript 是一种动态、弱类型的脚本语言，主要用于增强网页的交互性。它可以在浏览器中运行，也可以在服务器端使用（如 Node.js）。JavaScript 代码通常嵌入在 HTML 文档中，通过 \u0026lt;script\u0026gt; 标签引入。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JavaScript Example\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello, JavaScript!\u0026lt;/h1\u0026gt; \u0026lt;script\u0026gt; console.log(\u0026#34;Hello, World!\u0026#34;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 2. JavaScript 基本语法 变量声明 JavaScript 使用 var、let 和 const 关键字来声明变量。\n1 2 3 let name = \u0026#34;Alice\u0026#34;; // 使用 let 声明变量 const age = 25; // 使用 const 声明常量 var isStudent = true; // 使用 var 声明变量（不推荐） var 关键字声明的变量具有函数作用域，而 let 和 const 具有块级作用域。推荐使用 let 和 const 来避免变量提升和作用域问题。\n数据类型 JavaScript 支持多种数据类型，包括：\n原始类型：String（字符串）、Number（数字）、Boolean（布尔值）、Null（空值）、Undefined（未定义）、Symbol（符号） 复杂类型：Object（对象）、Array（数组）、Function（函数） 1 2 3 4 5 let message = \u0026#34;Hello\u0026#34;; // String let count = 10; // Number let isActive = true; // Boolean let person = { name: \u0026#34;Bob\u0026#34;, age: 30 }; // Object let numbers = [1, 2, 3, 4, 5]; // Array 函数定义 函数是 JavaScript 的核心组成部分，可以通过多种方式定义。\n1 2 3 4 5 6 7 8 9 10 // 函数声明 function greet(name) { return \u0026#34;Hello, \u0026#34; + name + \u0026#34;!\u0026#34;; } // 函数表达式 const add = function(a, b) { return a + b; }; // 箭头函数 const multiply = (a, b) =\u0026gt; a * b; 箭头函数是 ES6 引入的一种简洁的函数定义方式，适用于简短的函数。\n条件语句 1 2 3 4 5 if (age \u0026gt;= 18) { console.log(\u0026#34;Adult\u0026#34;); } else { console.log(\u0026#34;Minor\u0026#34;); } 循环语句 1 2 console.log(i); } 事件处理 1 2 3 document.getElementById(\u0026#34;myButton\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, function() { alert(\u0026#34;Button clicked!\u0026#34;); }); 其中document是DOM（文档对象模型）的入口，getElementById方法用于获取指定ID的HTML元素，addEventListener方法用于为元素添加事件监听器。alert函数用于显示弹窗。\nJavaScript 语法糖 ES6 引入了许多语法糖，使代码更简洁易读。语法糖是指一些语法特性，它们并不增加语言的功能，但可以让代码更易于编写和理解。例如：\n1 2 3 4 5 6 7 // 传统函数定义 var add = function(a, b) { return a + b; }; // 箭头函数 const add = (a, b) =\u0026gt; a + b; 还有模板字符串、解构赋值、默认参数等：\n1 2 3 4 5 6 7 8 9 // 模板字符串 let name = \u0026#34;Alice\u0026#34;; let greeting = `Hello, ${name}!`; // 解构赋值 let [x, y] = [1, 2]; // 默认参数 function multiply(a, b = 1) { return a * b; } 3. JavaScript 应用场景 JavaScript 广泛应用于以下场景：\n前端开发：实现网页的动态效果和交互功能。 后端开发：使用 Node.js 构建服务器端应用。 移动应用开发：使用 React Native、Ionic 等框架开发跨平台移动应用。 桌面应用开发：使用 Electron 构建跨平台桌面应用。 游戏开发：使用 Phaser、Three.js 等库开发网页游戏。 物联网（IoT）：使用 JavaScript 控制硬件设备。 数据可视化：使用 D3.js、Chart.js 等库进行数据可视化展示。 4. 总结 JavaScript 是一种功能强大且灵活的编程语言，广泛应用于各种开发场景。通过掌握其基本概念和语法，初学者可以快速上手并开始构建自己的网页和应用程序。继续深入学习 JavaScript 的高级特性和框架，将有助于提升开发技能和项目质量。在现代前端开发中，许多框架和库（如 React、Vue、Angular）都依赖于 JavaScript，因此掌握这门语言对于前端开发者来说尤为重要。而JavaScript的超集TypeScript也越来越受各大公司青睐，学习JavaScript的同时也可以了解一下TypeScript。\n5. 参考资料 MDN Web Docs - JavaScript JavaScript.info W3Schools - JavaScript Tutorial ","date":"2025-10-11T21:37:37+08:00","permalink":"https://adam-code-line.github.io/p/javascript/","title":"JavaScript 基础知识入门"},{"content":"CSS 基础知识入门 CSS（层叠样式表）是用于描述 HTML 文档外观和格式的语言。本文将介绍 CSS 的基本概念、选择器及其应用，帮助初学者快速入门。\n1. CSS 基本概念 CSS 用于控制网页的布局、颜色、字体等视觉效果。它可以与 HTML 结合使用，通过选择器选择 HTML 元素并应用样式规则。 一个简单的 CSS 规则如下：\n1 2 3 selector { property: value; } selector：选择器，指定要应用样式的 HTML 元素。 property：属性，指定要设置的样式属性，如颜色、字体大小等。 value：值，指定属性的具体值。 2. 常用 CSS 选择器 元素选择器 元素选择器直接使用 HTML 标签名来选择元素。\n1 2 3 4 p { color: blue; font-size: 16px; } 类选择器 类选择器使用 . 符号，选择具有特定类名的元素。\n1 2 3 4 5 6 .button { background-color: green; color: white; padding: 10px 20px; border-radius: 5px; } ID 选择器 ID 选择器使用 # 符号，选择具有特定 ID 的元素。\n1 2 3 4 5 #header { background-color: lightgray; text-align: center; padding: 20px; } 组合选择器 组合选择器可以同时使用多种选择器来选择元素。\n1 2 3 4 div.container p { margin: 10px 0; line-height: 1.5; } 3. CSS 应用方式 CSS 可以通过三种方式应用到 HTML 文档中：\n内联样式 内联样式直接在 HTML 元素的 style 属性中定义样式。\n1 \u0026lt;p style=\u0026#34;color: red; font-size: 14px;\u0026#34;\u0026gt;This is a red paragraph.\u0026lt;/p\u0026gt; 内部样式表 内部样式表在 HTML 文档的 \u0026lt;head\u0026gt; 部分使用 \u0026lt;style\u0026gt; 标签定义样式。\n1 2 3 4 5 6 7 8 \u0026lt;head\u0026gt; \u0026lt;style\u0026gt; body { font-family: Arial, sans-serif; background-color: #f0f0f0; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; 外部样式表 外部样式表将 CSS 代码放在单独的 .css 文件中，并通过 \u0026lt;link\u0026gt; 标签引入。\n1 2 3 \u0026lt;head\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;styles.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; 其中rel属性指定链接类型，href属性指定CSS文件路径。\n4. 常用 CSS 属性 颜色属性 1 2 color: blue; /* 文字颜色 */ background-color: yellow; /* 背景颜色 */ 字体属性 1 2 3 font-size: 16px; /* 字体大小 */ font-family: \u0026#39;Arial\u0026#39;, sans-serif; /* 字体类型 */ font-weight: bold; /* 字体粗细 */ 布局属性 1 2 3 4 5 margin: 10px; /* 外边距 */ padding: 15px; /* 内边距 */ border: 1px solid black; /* 边框 */ width: 100%; /* 宽度 */ height: 200px; /* 高度 */ 5. 总结 css 是网页设计中不可或缺的技术，掌握其基本概念和常用选择器对于前端开发十分有帮助。现代的前端开发中，还会使用css预处理器（如Sass、Less）和框架（如Bootstrap、Tailwind CSS）来提高开发效率。能够熟练运用css，将大大提升网页的视觉效果和用户体验。\n6. 参考资料 MDN Web Docs - CSS ","date":"2025-10-11T21:28:45+08:00","permalink":"https://adam-code-line.github.io/p/css/","title":"CSS 基础知识入门"},{"content":"HTML 基础知识入门 HTML（超文本标记语言）是构建网页的基础语言。本文将介绍 HTML 的基本概念、常用标签及其结构，帮助初学者快速入门。\n1. HTML 基本结构 一个标准的 HTML 文档包含以下基本结构：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is a simple HTML document.\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;!DOCTYPE html\u0026gt;：声明文档类型，告诉浏览器使用 HTML5 标准。 \u0026lt;html\u0026gt;：根元素，包含整个 HTML 文档。 \u0026lt;head\u0026gt;：包含文档的元数据，如字符集、标题和样式表。 \u0026lt;body\u0026gt;：包含网页的内容，如文本、图片和链接。 2. 常用 HTML 标签 标题标签 HTML 提供了六个级别的标题标签，分别是 \u0026lt;h1\u0026gt; 到 \u0026lt;h6\u0026gt;，其中 \u0026lt;h1\u0026gt; 是最高级别的标题。\n1 2 3 \u0026lt;h1\u0026gt;Main Title\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;Sub Title\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;Section Title\u0026lt;/h3\u0026gt; 段落标签 段落使用 \u0026lt;p\u0026gt; 标签表示。\n1 2 \u0026lt;p\u0026gt;This is a paragraph.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;This is another paragraph.\u0026lt;/p\u0026gt; 链接标签 链接使用 \u0026lt;a\u0026gt; 标签，href 属性指定链接地址。\n1 \u0026lt;a href=\u0026#34;https://www.example.com\u0026#34;\u0026gt;Visit Example.com\u0026lt;/a\u0026gt; 图片标签 图片使用 \u0026lt;img\u0026gt; 标签，src 属性指定图片路径，alt 属性提供替代文本。\n1 \u0026lt;img src=\u0026#34;image.jpg\u0026#34; alt=\u0026#34;Description of image\u0026#34;\u0026gt; 列表标签 HTML 支持有序列表和无序列表。\n有序列表使用 \u0026lt;ol\u0026gt; 标签，列表项使用 \u0026lt;li\u0026gt; 标签。 1 2 3 4 \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;First item\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Second item\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; 无序列表使用 \u0026lt;ul\u0026gt; 标签。 1 2 3 4 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;First item\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Second item\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 表格标签 表格使用 \u0026lt;table\u0026gt; 标签，表头使用 \u0026lt;th\u0026gt;，表行使用 \u0026lt;tr\u0026gt;，表格数据使用 \u0026lt;td\u0026gt;。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;Name\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Age\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Alice\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;30\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Bob\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;25\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; 3. HTML 属性 HTML 标签可以包含属性，用于提供额外的信息或配置。例如：\n1 2 \u0026lt;a href=\u0026#34;https://www.example.com\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;Open in new tab\u0026lt;/a\u0026gt; \u0026lt;img src=\u0026#34;image.jpg\u0026#34; alt=\u0026#34;Description\u0026#34; width=\u0026#34;600\u0026#34; height=\u0026#34;400\u0026#34;\u0026gt; href：指定链接地址。 target：指定链接打开方式，如 _blank 表示在新标签页打开。 width 和 height：指定图片的宽度和高度。 alt：提供图片的替代文本。 4. HTML 注释 HTML 注释使用 \u0026lt;!-- --\u0026gt; 包围，浏览器不会渲染注释内容。\n1 2 \u0026lt;!-- This is a comment --\u0026gt; \u0026lt;p\u0026gt;This is visible content.\u0026lt;/p\u0026gt; 5. 总结 本文介绍了 HTML 的基本结构、常用标签及其属性。掌握这些基础知识后，您可以开始创建简单的网页，并逐步深入学习更高级的 HTML 和前端技术。继续探索 HTML5 新特性，如多媒体标签（\u0026lt;video\u0026gt;、\u0026lt;audio\u0026gt;）和表单标签（\u0026lt;form\u0026gt;、\u0026lt;input\u0026gt;），将帮助您构建更丰富的网页内容。\n6. 参考资料 MDN Web Docs - HTML W3Schools - HTML Tutorial ","date":"2025-10-11T16:52:09+08:00","permalink":"https://adam-code-line.github.io/p/html/","title":"HTML 基础知识入门"},{"content":"Vue v-for 指令详解 v-for 是 Vue.js 中用于渲染列表的指令，允许你基于一个数组或对象动态生成多个元素。本文将详细介绍 v-for 的用法、语法以及一些常见的实践。\n1. 基本语法 v-for 的基本语法如下：\n1 2 3 4 5 6 7 \u0026lt;template\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;item in items\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt; {{ item.name }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/template\u0026gt; 在这个例子中，items 是一个数组，item 是数组中的每个元素。v-for 会遍历 items 数组，并为每个元素生成一个 \u0026lt;li\u0026gt; 元素。 而 :key 是一个特殊属性，用于帮助 Vue 跟踪每个节点的身份，从而提高渲染效率。\n分隔符：v-for 的分隔符是 in，用于指定要遍历的数组或对象,但也可以使用 of 来替代 in。 2. 作用域 v-for 创建了一个新的作用域，在这个作用域内你可以访问当前迭代的元素以及它的索引：\n1 2 3 4 5 6 7 8 \u0026lt;template\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(item, index) in items\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt; \u0026lt;!-- 此处可以访问外层的变量，但`item`和`index`只能在该作用域内使用 --\u0026gt; {{ index }} - {{ item.name }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/template\u0026gt; 3. 遍历对象 除了遍历数组，v-for 也可以用来遍历对象的属性：\n1 2 3 4 5 6 7 \u0026lt;template\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(value, key) in object\u0026#34; :key=\u0026#34;key\u0026#34;\u0026gt; {{ key }}: {{ value }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/template\u0026gt; 在这个例子中，object 是一个对象，key 是对象的属性名，value 是对应的属性值。\n4. 获取索引 你还可以在 v-for 中获取当前元素的索引：\n1 2 3 4 5 6 7 \u0026lt;template\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(item, index) in items\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt; {{ index }} - {{ item.name }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/template\u0026gt; 这里，index 是当前元素在数组中的索引。\n5. 使用 v-for 渲染组件 v-for 也可以用来渲染自定义组件：\n1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;my-component v-for=\u0026#34;item in items\u0026#34; :key=\u0026#34;item.id\u0026#34; :data=\u0026#34;item\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 在这个例子中，my-component 是一个自定义组件，data 是传递给组件的属性。\n6. 注意事项 唯一的 key：确保每个元素都有一个唯一的 key，这对于 Vue 的虚拟 DOM 进行高效更新非常重要。 避免使用索引作为 key：除非列表是静态的或不会被重新排序，否则不建议使用索引作为 key，因为这可能会导致渲染问题。 性能考虑：对于大型列表，考虑使用虚拟滚动或分页来提高性能。 嵌套 v-for：可以在一个元素内嵌套多个 v-for，但要注意性能和可读性。 1 2 3 4 5 6 7 8 9 10 \u0026lt;template\u0026gt; \u0026lt;div v-for=\u0026#34;(group, groupIndex) in groups\u0026#34; :key=\u0026#34;group.id\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;{{ group.name }}\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(item, itemIndex) in group.items\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt; {{ item.name }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 7. 结合其他指令使用 当位于于同一元素上时，v-for 的优先级低于 v-if。这意味着 v-if 会先于 v-for 被处理，此时 v-if 的条件将无法访问到 v-for 作用域内定义的变量别名。\n1 2 3 4 5 6 7 8 \u0026lt;!--这会抛出错误，因为属性 it 在 v-if 中没有定义--\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p v-for=\u0026#34;it in items\u0026#34; v-if=\u0026#34;it.isActive\u0026#34; :key=\u0026#34;it.id\u0026#34;\u0026gt; {{ it.name }} \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 可以在外层包裹一个 \u0026lt;template\u0026gt; 标签来解决这个问题：\n1 2 3 4 5 6 7 8 9 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;template v-for=\u0026#34;item in items\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt; \u0026lt;p v-if=\u0026#34;item.isActive\u0026#34;\u0026gt; {{ item.name }} \u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 8. 总结 v-for 是 Vue.js 中非常强大且常用的指令，能够帮助开发者高效地渲染列表和处理动态数据。通过理解其语法、作用域以及与其他指令的结合使用，可以更好地利用 v-for 来构建复杂的用户界面。希望本文能帮助你更深入地理解和应用 v-for 指令。\n9. 参考资料 Vue.js 官方文档 - 列表渲染 ","date":"2025-10-11T16:03:55+08:00","permalink":"https://adam-code-line.github.io/p/vue-v-for-guide/","title":"Vue v-for 指令详解"},{"content":"Vue 条件渲染：v-if vs v-show 在 Vue.js 中，条件渲染是构建动态用户界面的重要技术。Vue 提供了两种主要的条件渲染指令：v-if 和 v-show。本文将探讨这两者的区别、使用场景及其底层原理，帮助开发者更好地选择合适的指令来优化应用性能和用户体验。\n1. v-if 的工作原理与使用 v-if 指令用于根据条件动态地添加或移除 DOM 元素。当条件为真时，Vue 会创建并插入元素；当条件为假时，Vue 会销毁并移除元素。\n使用示例 1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p v-if=\u0026#34;isVisible\u0026#34;\u0026gt;这是一个可见的段落。\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; v-if 与 v-else 和 v-else-if v-if 可以与 v-else 和 v-else-if 结合使用，以实现多条件渲染。\n1 2 3 4 5 6 7 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p v-if=\u0026#34;status === \u0026#39;success\u0026#39;\u0026#34;\u0026gt;操作成功！\u0026lt;/p\u0026gt; \u0026lt;p v-else-if=\u0026#34;status === \u0026#39;error\u0026#39;\u0026#34;\u0026gt;操作失败！\u0026lt;/p\u0026gt; \u0026lt;p v-else\u0026gt;操作进行中...\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; v-if 控制多元素的渲染 v-if 也可以用于控制多个元素的渲染，通过包裹在一个父元素中实现。\n1 2 3 4 5 6 \u0026lt;template\u0026gt; \u0026lt;div v-if=\u0026#34;isVisible\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;标题\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;这是一个段落。\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 或者在 Vue 3 中使用 \u0026lt;template\u0026gt; 标签：\n1 2 3 4 \u0026lt;template v-if=\u0026#34;isVisible\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;标题\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;这是一个段落。\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; 2. v-show 的工作原理与使用 v-show 指令也用于条件渲染，但其工作原理与 v-if 不同。v-show 通过设置元素的 CSS display 属性来控制元素的显示与隐藏。当条件为真时，元素会被渲染并显示；当条件为假时，元素仍然存在于 DOM 中，但会被隐藏。\n使用示例 1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p v-show=\u0026#34;isVisible\u0026#34;\u0026gt;这是一个可见的段落。\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 3. v-if vs v-show 的区别 特性 v-if v-show DOM 操作 动态添加和移除元素 仅切换 CSS display 属性 初始渲染性能 较慢，因为需要创建和销毁元素 较快，因为元素始终存在于 DOM 中 适用场景 条件不频繁变化的情况 条件频繁变化的情况 内存占用 较低，因为不需要保留元素 较高，因为元素始终存在于 DOM 中 事件监听 事件监听器会被移除 事件监听器始终存在 4. 选择指南 使用 v-if 当条件不频繁变化，且需要节省内存时。例如，用户登录状态的切换。 使用 v-show 当条件频繁变化，且需要快速切换显示状态时。例如，选项卡切换或模态框显示。 5. 执行顺序 在 Vue 的渲染过程中，当 v-if 和 v-show 同时存在于一个元素的时候，v-if 会优先执行。也就是说，如果 v-if 条件为假，元素不会被渲染，v-show 的条件将不会被评估。但 Vue 官方并不推荐同时使用这两个指令在同一个元素上，因为这可能会导致代码的可读性和维护性降低。\n6. 总结 在选择使用 v-if 还是 v-show 时，开发者需要根据具体的业务场景和性能需求来做出决策。一般来说，v-if 更适合用于条件不频繁变化的场景，而 v-show 则更适合用于需要频繁切换显示状态的场景。通过合理地使用这两种指令，可以有效地提升 Vue 应用的性能和用户体验。\n7. 参考资料 Vue.js 官方文档 - 条件渲染 ","date":"2025-10-11T11:07:50+08:00","permalink":"https://adam-code-line.github.io/p/v-if-v-show/","title":"Vue 条件渲染：v-if vs v-show"},{"content":"Vue 计算属性原理 本文为想学习 Vue 计算属性的前端开发者准备，涵盖 computed 的工作原理及其在 Vue 3 中的实现机制。\n1. 为什么学习计算属性原理 Vue的计算属性能够描述依赖响应式状态复杂逻辑，并且计算属性值会基于其响应式依赖被缓存,只有在computed属性的响应式依赖发生变化时才会重新计算。这种特性使得计算属性在性能优化和代码简洁性方面具有显著优势。\n2. 计算属性的工作原理 计算属性通过 computed 函数创建，接受一个 getter 函数，并返回一个包含 .value 属性的响应式对象。其核心原理如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 function computed(getterOrOptions) { // getter 函数 let getter; // setter 函数 let setter; // 标准化参数 if (isFunction(getterOrOptions)) { // 表面传入的是 getter 函数，不能修改计算属性的值 getter = getterOrOptions; setter = process.env.NODE_ENV !== \u0026#34;production\u0026#34; ? () =\u0026gt; { console.warn(\u0026#34;Write operation failed: computed value is readonly\u0026#34;); } : NOOP; } else { getter = getterOrOptions.get; setter = getterOrOptions.set; } // 数据是否脏的 let dirty = true; // 计算结果 let value; let computed; // 创建副作用函数 const runner = effect(getter, { // 延时执行 lazy: true, // 标记这是一个 computed effect 用于在 trigger 阶段的优先级排序 computed: true, // 调度执行的实现 scheduler: () =\u0026gt; { if (!dirty) { dirty = true; // 派发通知，通知运行访问该计算属性的 activeEffect trigger(computed, \u0026#34;set\u0026#34; /* SET */, \u0026#34;value\u0026#34;); } }, }); // 创建 computed 对象 computed = { __v_isRef: true, // 暴露 effect 对象以便计算属性可以停止计算 effect: runner, get value() { // 计算属性的 getter if (dirty) { // 只有数据为脏的时候才会重新计算 value = runner(); dirty = false; } // 依赖收集，收集运行访问该计算属性的 activeEffect track(computed, \u0026#34;get\u0026#34; /* GET */, \u0026#34;value\u0026#34;); return value; }, set value(newValue) { // 计算属性的 setter setter(newValue); }, }; return computed; } 脏检查：计算属性通过 dirty 标志来判断是否需要重新计算值。当依赖的响应式数据发生变化时，调度器会将 dirty 设置为 true。 依赖收集：当访问计算属性的 .value 时，会调用 track 函数，将当前的副作用函数与该计算属性关联起来。 触发更新：当计算属性的依赖发生变化时，调度器会调用 trigger 函数，通知所有依赖该计算属性的副作用函数重新执行。 缓存机制：计算属性只有在其依赖发生变化时才会重新计算，这通过 dirty 标志实现，从而提高性能。 3. 可写计算属性 计算属性默认是只读的，当尝试修改一个计算属性时，会在开发环境下发出警告，但在某些情况下，我们也可以同时提供getter和setter来创建可写的计算属性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;script setup\u0026gt; import { ref, computed } from \u0026#39;vue\u0026#39; const firstName = ref(\u0026#39;Li\u0026#39;) const lastName = ref(\u0026#39;Hua\u0026#39;) const fullName = computed({ // getter get() { return firstName.value + \u0026#39; \u0026#39; + lastName.value }, // setter set(newValue) { //这里使用的是解构赋值语法 [firstName.value, lastName.value] = newValue.split(\u0026#39; \u0026#39;) } }) \u0026lt;/script\u0026gt; 4. 计算属性与普通方法的区别 计算属性与普通方法的主要区别在于缓存机制。普通方法每次调用都会执行函数体，而计算属性只有在其依赖发生变化时才会重新计算，这使得计算属性在性能上更优。\n计算属性更适合用于依赖响应式数据的复杂逻辑，而普通方法更适合用于不依赖响应式数据的简单逻辑。\n5. 计算属性的实际应用 计算属性在实际开发中有广泛的应用场景，例如：\n表单输入的实时验证：可以使用计算属性来根据输入的值动态计算验证结果，从而实现实时反馈。 复杂数据的展示：在展示复杂数据时，可以使用计算属性来处理数据的格式化和转换，简化模板逻辑。 依赖于多个数据源的计算：当一个值依赖于多个响应式数据时，可以使用计算属性来集中管理这些依赖关系，提高代码的可维护性。 1 2 3 const total = computed(() =\u0026gt; { return items.reduce((sum, item) =\u0026gt; sum + item.price * item.quantity, 0) }) 6. 总结 通过学习 Vue 计算属性的工作原理，开发者可以更好地理解其内部机制，从而在实际开发中更有效地利用这一特性。计算属性不仅提高了代码的简洁性和可读性，还通过缓存机制优化了性能，是 Vue 开发中不可或缺的工具。\n7. 参考资料 Vue.js 官方文档 - 计算属性 深入浅出 Vue 计算属性 computed 的使用与优化 计算属性：Vue3探秘系列— computed的实现原理（六） ","date":"2025-10-09T18:45:11+08:00","permalink":"https://adam-code-line.github.io/p/computed/","title":"Vue 计算属性原理 "},{"content":"Vue 响应式原理 本文为想学习 Vue 响应式系统的前端开发者准备，涵盖 ref 和 reactive 的工作原理及其在 Vue 3 中的实现机制。\n1. 为什么学习响应式原理 学习 Vue 的响应式原理可以帮助开发者更好地理解框架的内部机制，从而在实际开发中更有效地利用这些特性。掌握响应式原理有助于：\n提高调试能力：了解数据是如何变化的，可以更快地定位问题。 优化性能：通过合理使用响应式 API，减少不必要的渲染和计算。 增强代码可读性：清晰的理解数据流动，有助于编写更易于维护的代码。 2. Vue 响应式系统概述 Vue 3 的响应式系统基于 ES6 的 Proxy 对象实现，主要通过 ref 和 reactive 两个 API 来创建响应式数据。\nref：用于创建基本类型的响应式数据，如字符串、数字、布尔值等。它返回一个包含 .value 属性的对象。 reactive：用于创建复杂类型的响应式数据，如对象和数组。 这两个 API 都会追踪数据的变化，并在数据更新时通知相关的组件进行重新渲染。\n3. ref 的工作原理 ref 函数接受一个初始值，并返回一个包含该值的响应式对象。其核心原理如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function ref(initialValue) { const r = { get value() { // 依赖收集 track(r, \u0026#39;value\u0026#39;) return initialValue }, set value(newValue) { initialValue = newValue // 触发更新 trigger(r, \u0026#39;value\u0026#39;) } } return r } 依赖收集：当访问 ref 的 .value 属性时，会调用 track 函数，将当前的副作用函数（如组件的渲染函数）与该属性关联起来。 触发更新：当修改 .value 属性时，会调用 trigger 函数，通知所有依赖该属性的副作用函数重新执行。 4. reactive 的工作原理 reactive 函数接受一个对象，并返回该对象的响应式代理。其核心原理如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function reactive(target) { return new Proxy(target, { get(target, key) { // 依赖收集 track(target, key) return Reflect.get(target, key) }, set(target, key, value) { const result = Reflect.set(target, key, value) // 触发更新 trigger(target, key) return result } }) } 依赖收集：当访问对象的属性时，会调用 track 函数，将当前的副作用函数与该属性关联起来。 触发更新：当修改对象的属性时，会调用 trigger 函数，通知所有依赖该属性的副作用函数重新执行。 5. 依赖追踪与副作用函数 Vue 使用一个全局的 activeEffect 变量来追踪当前正在执行的副作用函数。当副作用函数执行时，activeEffect 会被设置为该函数。当访问响应式数据时，track 函数会将 activeEffect 与该数据关联起来。\n1 2 3 4 5 6 7 8 9 let activeEffect = null function effect(fn) { const effectFn = () =\u0026gt; { activeEffect = effectFn fn() activeEffect = null } effectFn() } effect 函数：接受一个函数作为参数，并将其包装为副作用函数。执行该函数时，会设置 activeEffect，从而实现依赖收集。 track 函数：将 activeEffect 与访问的属性关联起来，存储在一个依赖集合中。 trigger 函数：当属性值发生变化时，遍历依赖集合，执行所有关联的副作用函数。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 const targetMap = new WeakMap() function track(target, key) { if (!activeEffect) return let depsMap = targetMap.get(target) if (!depsMap) { depsMap = new Map() targetMap.set(target, depsMap) } let dep = depsMap.get(key) if (!dep) { dep = new Set() depsMap.set(key, dep) } dep.add(activeEffect) } function trigger(target, key) { const depsMap = targetMap.get(target) if (!depsMap) return const dep = depsMap.get(key) if (dep) { dep.forEach(effect =\u0026gt; effect()) } } targetMap：使用 WeakMap 存储每个响应式对象及其属性的依赖集合。 track 函数：将当前的 activeEffect 添加到对应属性的依赖集合中。 trigger 函数：遍历属性的依赖集合，执行所有副作用函数。 6. ref 与 reactive 的区别与联系 数据类型：ref 适用于基本类型数据，而 reactive 适用于对象和数组。 访问方式：ref 需要通过 .value 访问和修改值，而 reactive 可以直接通过属性访问和修改。 嵌套响应式：reactive 会递归地将嵌套对象转换为响应式，而 ref 只会对其初始值进行响应式处理。 性能：ref 在处理大量基本类型数据时，性能可能优于 reactive，因为后者需要处理更多的代理逻辑。 使用注意： reactive底层是通过Proxy实现的，因此不能直接对reactive对象进行解构赋值，否则会失去响应式特性，同样它也不能监听原始数据类型。相反，ref可以安全地解构，因为它返回的是一个包含.value属性的对象。 7. 总结 通过学习 Vue 的响应式原理，开发者可以更深入地理解框架的工作机制，从而在实际开发中更有效地利用这些特性。掌握 ref 和 reactive 的实现原理，有助于提高调试能力、优化性能，并编写更易于维护的代码。\n8. 参考资料 Vue 3 源码解析 Vue3响应式：ref vs reactive，5分钟消除使用困惑 ","date":"2025-10-09T17:00:49+08:00","permalink":"https://adam-code-line.github.io/p/ref-reactive/","title":"Vue 响应式原理 "},{"content":"TypeScript 学习指南 本文为想系统学习 TypeScript 的前端开发者准备，覆盖从基础类型、配置、进阶类型到在 Vue 项目中使用 TypeScript 的简单实战示例。\n1. 为什么学 TypeScript 静态类型可以在编译期发现很多常见错误，提高代码可维护性。 与现代 IDE（例如 VS Code）结合，能获得更好的智能提示、重构支持和文档提示。 2. 快速开始 1 2 3 4 # 初始化项目 pnpm init -y pnpm add -D typescript npx tsc --init 这会生成 tsconfig.json。\n一个常见的 tsconfig.json 最小配置：\n1 2 3 4 5 6 7 8 9 10 11 12 { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;ES2020\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;ESNext\u0026#34;, \u0026#34;moduleResolution\u0026#34;: \u0026#34;Node\u0026#34;, \u0026#34;strict\u0026#34;: true, \u0026#34;jsx\u0026#34;: \u0026#34;preserve\u0026#34;, \u0026#34;esModuleInterop\u0026#34;: true, \u0026#34;skipLibCheck\u0026#34;: true, \u0026#34;forceConsistentCasingInFileNames\u0026#34;: true } } 3. 基础类型示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 原始类型 let s: string = \u0026#39;hello\u0026#39; let n: number = 123 let b: boolean = true // 数组与元组 let arr: number[] = [1,2,3] let tup: [string, number] = [\u0026#39;age\u0026#39;, 18] // 联合类型与类型别名 type ID = string | number let id: ID = \u0026#39;abc\u0026#39; // 接口与类型 interface User { id: ID; name: string } const user: User = { id: \u0026#39;u1\u0026#39;, name: \u0026#39;Alice\u0026#39; } // 函数类型 function add(a: number, b: number): number { return a + b } 4. 进阶类型 泛型（Generics） 映射类型（Mapped Types） 条件类型（Conditional Types） 泛型示例：\n1 2 function identity\u0026lt;T\u0026gt;(arg: T): T { return arg } const s = identity\u0026lt;string\u0026gt;(\u0026#39;hi\u0026#39;) 5. 在 Vue 中使用 TypeScript 推荐使用 script setup lang=\u0026quot;ts\u0026quot;。 在 Vite + Vue 项目中，shims-vue.d.ts 可能需要声明 Vue 文件支持： 1 2 3 4 5 declare module \u0026#39;*.vue\u0026#39; { import { DefineComponent } from \u0026#39;vue\u0026#39; const component: DefineComponent\u0026lt;{}, {}, any\u0026gt; export default component } 组件示例：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { defineProps } from \u0026#39;vue\u0026#39; interface Props { title: string } const props = defineProps\u0026lt;Props\u0026gt;() \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;h1\u0026gt;{{ props.title }}\u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; 6. 常见模式与技巧 使用 as const 固定字面量类型。 使用 unknown 代替 any 做更严格的类型收敛。 使用 ReturnType\u0026lt;\u0026gt;, Partial\u0026lt;\u0026gt;, Required\u0026lt;\u0026gt; 等工具类型提高复用性。 7. 配合工具链 ESLint 与 TypeScript: 使用 @typescript-eslint/parser 和 @typescript-eslint/eslint-plugin。 编辑器：确保安装 TypeScript 相关插件并在项目中使用本地 TypeScript（避免全局版本不一致）。 8. 练习任务 把一个小型 JS 项目迁移到 TypeScript（从 --strict 放宽到逐步开启 strict 规则）。 写一个简单的泛型工具函数并写测试（Vitest）。 9. 参考资源 TypeScript 官方文档 TypeScript Deep Dive Vue + TypeScript 官方指南 TypeScript ESLint ","date":"2025-10-01T11:35:10+08:00","image":"https://adam-code-line.github.io/p/typescript-learning-guide/cover_hu_eee5813ff9235310.jpg","permalink":"https://adam-code-line.github.io/p/typescript-learning-guide/","title":"TypeScript"},{"content":"Vue 学习指南 这篇指南面向想系统学习 Vue 3 的开发者，覆盖从环境搭建、组合式 API、组件设计、路由、状态管理到测试与部署的简单实用示例和练习。\n1. 开发环境与快速启动 推荐使用 Node.js（16+）与 Vite 创建项目：\n1 2 3 4 5 6 7 8 # 全局安装（可选） npm install -g pnpm # 使用 pnpm 创建项目 pnpm create vite@latest my-vue-app -- --template vue-ts cd my-vue-app pnpm install pnpm dev 打开 http://localhost:5173 即可预览。\n2. 核心概念（简要） 组件（Components）：UI 的可复用单元。 响应式（Reactivity）：ref、reactive 提供响应式数据。 生命周期钩子：onMounted、onUnmounted 等。 组合式 API（Composition API）：使用 setup() 或 script setup 来组织逻辑。 3. 组合式 API 基本示例 以下示例展示计数器的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count: {{ count }}\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { ref } from \u0026#39;vue\u0026#39; const count = ref(0) function increment() { count.value++ } \u0026lt;/script\u0026gt; 4. 组件传参与事件 父组件向子组件传递 props，并通过 emit 触发事件：\nChild.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;onClick\u0026#34;\u0026gt;{{ label }}\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { defineProps, defineEmits } from \u0026#39;vue\u0026#39; const props = defineProps\u0026lt;{ label: string }\u0026gt;() const emit = defineEmits\u0026lt;{ (e: \u0026#39;clicked\u0026#39;): void }\u0026gt;() function onClick() { emit(\u0026#39;clicked\u0026#39;) } \u0026lt;/script\u0026gt; Parent.vue\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;template\u0026gt; \u0026lt;Child label=\u0026#34;Click me\u0026#34; @clicked=\u0026#34;handle\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import Child from \u0026#39;./Child.vue\u0026#39; function handle() { console.log(\u0026#39;child clicked\u0026#39;) } \u0026lt;/script\u0026gt; 5. 路由（Vue Router）基础 安装并配置 Vue Router：\n1 pnpm add vue-router@4 src/router/index.ts 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 import { createRouter, createWebHistory } from \u0026#39;vue-router\u0026#39; import Home from \u0026#39;../views/Home.vue\u0026#39; import About from \u0026#39;../views/About.vue\u0026#39; const routes = [ { path: \u0026#39;/\u0026#39;, component: Home }, { path: \u0026#39;/about\u0026#39;, component: About }, ] export const router = createRouter({ history: createWebHistory(), routes, }) 在 main.ts 中挂载：\n1 2 3 4 5 import { createApp } from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import { router } from \u0026#39;./router\u0026#39; createApp(App).use(router).mount(\u0026#39;#app\u0026#39;) 6. 状态管理（Pinia） 使用 Pinia 取代 Vuex：\n1 pnpm add pinia 示例 store：\n1 2 3 4 5 6 7 8 9 // stores/counter.ts import { defineStore } from \u0026#39;pinia\u0026#39; import { ref } from \u0026#39;vue\u0026#39; export const useCounter = defineStore(\u0026#39;counter\u0026#39;, () =\u0026gt; { const count = ref(0) function increment() { count.value++ } return { count, increment } }) 在主应用中挂载 Pinia：\n1 2 import { createPinia } from \u0026#39;pinia\u0026#39; createApp(App).use(createPinia()).use(router).mount(\u0026#39;#app\u0026#39;) 组件中使用：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { useCounter } from \u0026#39;@/stores/counter\u0026#39; const counter = useCounter() \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{{ counter.count }}\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026#34;counter.increment\u0026#34;\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 7. 常用工具与测试 开发工具：Vite、ESLint、Prettier、TypeScript。 测试：Vitest + @vue/test-utils。 简单的 Vitest 测试示例：\n1 2 3 4 5 6 7 8 9 10 11 // tests/example.spec.ts import { describe, it, expect } from \u0026#39;vitest\u0026#39; import { mount } from \u0026#39;@vue/test-utils\u0026#39; import Hello from \u0026#39;../src/components/HelloWorld.vue\u0026#39; describe(\u0026#39;Hello\u0026#39;, () =\u0026gt; { it(\u0026#39;renders properly\u0026#39;, () =\u0026gt; { const wrapper = mount(Hello) expect(wrapper.text()).toContain(\u0026#39;Hello\u0026#39;) }) }) 8. 部署与发布建议 小型项目可以使用 Vercel 或 Netlify 直接部署，无需复杂配置。 打包命令： 1 2 3 pnpm build # 本地预览 pnpm preview 9. 参考资源 Vue 3 官方文档 Vue Router 文档 Pinia 文档 Vitest 文档 ","date":"2025-10-01T10:52:24+08:00","image":"https://adam-code-line.github.io/p/vue-learning-guide/cover_hu_1d9a212cbcfa3493.jpg","permalink":"https://adam-code-line.github.io/p/vue-learning-guide/","title":"Vue"},{"content":"前端学习路线 写博客是把自己学到的知识沉淀并分享给别人的好方法。本文模仿项目中的风格，给出一套清晰的前端学习路线，适用于刚入门的同学，也适合想系统提升的开发者。\n为什么需要一条明确的学习路线 前端技术栈庞杂，工具和框架迭代快。如果没有系统性的学习计划，容易在碎片化的资料中迷失，不知下一步该学什么。一个合理的路线能帮助你建立知识体系、提升可迁移能力，并且尽早能做出完整的项目。\n学习路线总览 阶段 0：准备 (工具, 英语, 开发环境) 阶段 1：基础前端三剑客 (HTML/CSS/JavaScript) 阶段 2：前端三件套 (框架, 路由, 状态管理) 阶段 3：进阶 (TypeScript, 构建工具, 性能, 无障碍) 阶段 4：全栈与工程化 (后端基础, 部署, 测试) 阶段 5：项目驱动学习与实习面试准备 下面逐步展开每个阶段的推荐内容与练习方式。\n阶段 0：准备 安装并熟练使用一套编辑器 (VS Code 推荐) 和常用插件 (格式化, ESLint, vue(official)). 学习使用 Git 与 GitHub，掌握基本的 push、分支与 Pull Request 流程。 提升阅读英文文档的能力，前端优秀资源大多以英文为主。 阶段 1：基础 (约 1–2 个月) HTML: 语义化标签, 表单, 可访问性 (ARIA) 基础. CSS: 盒模型, Flexbox, Grid, 响应式设计, 常见布局技巧. JavaScript: 语法, 闭包, 原型链, 异步 (Promise, async/await), 模块化. 练习：实现若干静态页面（登录页、博客列表页、卡片布局），并尝试移动端适配。\n阶段 2：前端三件套 (约 1–3 个月) 框架: Vue 3 (或 React/Angular, 视团队与个人喜好). 掌握组件, 组合式 API (Vue 的 script setup), 生命周期, Props/Emit. 路由: 客户端路由的使用与懒加载 (例如 Vue Router). 状态管理: Pinia (Vue) 或 Redux (React) 的基本模式与实践. 练习：基于框架实现一个小型应用（Todo、简单博客、记账工具），包含路由和状态管理。\n阶段 3：进阶 (约 2–4 个月) TypeScript: 类型系统, 泛型, 声明文件 (.d.ts), 与现有 JS 项目迁移技巧. 构建工具: Vite / Webpack / Rollup 的基础配置与性能优化思路. CSS 工具: TailwindCSS, 预处理器 (Sass/LESS), CSS Modules. 性能与可访问性: 懒加载, code-splitting, 图片优化, 无障碍 (a11y) 最佳实践. 练习：给已有项目引入 TypeScript，做一次性能审计并逐项优化。\n阶段 4：全栈与工程化 (约 2–4 个月) 后端基础: RESTful API, GraphQL, 基础数据库 (Postgres, MongoDB) 概念. 部署: Docker, CI/CD (GitHub Actions), 托管平台 (Vercel, Netlify, 云主机). 测试: 单元测试 (Vitest/Jest), 端到端测试 (Cypress). 监控与日志: Sentry, 性能监控 (Lighthouse). 练习：把应用后端作为简单服务部署，使用 GitHub Actions 做自动化部署。\n阶段 5：项目驱动学习与面试准备 用项目驱动: 选择一个中等复杂度的项目 (支持用户登录, 数据持久化, 文件上传, 搜索/筛选), 把学习的技术整合进来. 写技术博客与读源码: 把你遇到的问题记录成文章, 帮助他人也帮助自己. 面试题训练: 算法基础, 网络/浏览器原理, 系统设计的简要理解. 学习建议 输出优先于输入: 能把学到的知识写成文章或实现成项目, 才算真正掌握. 定期复盘: 每 2–4 周总结学习进度, 调整计划. 社区与开源: 参与讨论, PR, 能快速提升工程能力. 参考资源（部分） MDN (HTML/CSS/JS) Vue 官方文档 / React 官方文档 Vite, Tailwind, TypeScript 官方指南 学习路线图 ⬇️ 下载 前端学习路线图(出处:https://front-talk.com/roadmap) ","date":"2025-09-30T11:04:33+08:00","image":"https://adam-code-line.github.io/p/frontend-learning-path/cover_hu_ffc67913452221a7.jpg","permalink":"https://adam-code-line.github.io/p/frontend-learning-path/","title":"前端学习路线"},{"content":"第一次写博客 在很早之前就有过写博客的想法，但是一直没有付诸行动。直到最近，终于决定开始记录自己的生活和学习经历。一开始本来是想着自己写一个博客系统，但是考虑到时间和精力的问题，最终选择了使用Hugo这个静态网站生成器。经过一番折腾，终于搭建好了自己的个人博客网站。希望自己以后能够坚持更新，分享更多有趣的内容和有用的知识。\n","date":"2025-09-21T23:35:33+08:00","image":"https://adam-code-line.github.io/p/life/cover_hu_dde4c1f358e5b772.jpg","permalink":"https://adam-code-line.github.io/p/life/","title":"我的第一篇文章"}]